schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

scalar AWSJSON

input AWSUpdateSecretsInputIntegration {
  installationId: ID!
}

input AWSUpdateSecretsInputZero {
  secretsIds: [ID!]!
}

type AcceptInviteOutput {
  id: ID!
}

input BitbucketDownloadSecretsInput {
  isDownloadSecretsEnabled: Boolean!
  isDownloadVendorPriority: Boolean!
}

type BitbucketEnvironment {
  id: ID!
  isUsed: Boolean!
  name: String!
}

input BitbucketInputZero {
  integrationConnectId: ID!
  projectId: ID!
  secretsIds: [ID!]!
}

input BitbucketInstallInputIntegration {
  extra: String!
  vendorProjectName: String!
}

type BitbucketProject {
  environments: [BitbucketEnvironment!]!
  id: ID!
  name: String!
}

input BitbucketUpdateSecretsInputIntegration {
  installationId: ID!
}

input BitbucketUpdateSecretsInputZero {
  secretsIds: [ID!]!
}

type BitbucketWorkspaceProjects {
  id: ID!
  name: String!
  repositories: [BitbucketProject!]!
}

input BitbucketWorkspaceProjectsInput {
  integrationConnectId: ID!
  projectId: ID!
}

type BitbucketWorkspaceProjectsOutput {
  workspacesProjects: [BitbucketWorkspaceProjects!]!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type ChangePasswordOutput {
  email: String!
  id: ID!
}

type ChangeTeamOutput {
  id: ID!
  project: project
}

input CheckIntegrationDeployInput {
  integrationConnectId: ID
  operationId: ID
}

type CheckIntegrationDeployOutput {
  status: DeployStatusIntegration!
}

type CheckUserEmailExistOutput {
  isExist: Boolean!
}

input CliAccessTokensInput {
  code: String!
}

type CliAccessTokensOutput {
  accessToken: String!
}

input CloudflareAuthInput {
  accountId: ID!
  apiToken: String!
}

type CloudflareAuthOutput {
  integrationConnectId: ID!
}

input CloudflareDownloadSecretsInput {
  isDownloadSecretsEnabled: Boolean!
  isDownloadVendorPriority: Boolean!
}

type CloudflareEnvironment {
  id: ID!
  isUsed: Boolean!
  name: String!
}

input CloudflareInputZero {
  integrationConnectId: ID!
  projectId: ID!
  secretsIds: [ID!]!
}

input CloudflareInstallInputIntegration {
  extra: String!
  vendorProjectName: String!
}

type CloudflareProject {
  environments: [CloudflareEnvironment!]!
  id: ID!
  name: String!
}

input CloudflareProjectsInput {
  integrationConnectId: ID!
  projectId: ID!
}

type CloudflareProjectsOutput {
  projects: [CloudflareProject!]!
}

input CloudflareUpdateSecretsInputIntegration {
  installationId: ID!
}

input CloudflareUpdateSecretsInputZero {
  secretsIds: [ID!]!
}

type ConfirmEmailChangeOutput {
  accessToken: String!
  userId: ID!
}

type CreateCredentialProjectOutput {
  credentialProject: credentialProject
  id: ID!
  tokenValue: String!
}

input CreateCredentialProjectTokenInput {
  expiresAt: String
  name: String!
  projectId: ID!
}

type CreateCredentialProjectTokenOutput {
  credentialProjectToken: credentialToken
  id: ID!
  value: String!
}

type CreateProjectOutput {
  id: ID
  project: project
  tokenValue: String
}

input CreateProjectTokenInput {
  expiresAt: String
  name: String!
  projectId: ID!
}

type CreateProjectTokenOutput {
  id: ID!
  token: token
  value: String!
}

input CreateSecretFieldInput {
  name: String!
  value: String!
}

input CreateSecretInput {
  name: String!
  projectId: ID!
  slug: String!
  vendor: String!
}

type CreateSecretOutput {
  id: ID!
}

type CreateTeamOutput {
  id: ID!
}

type DecodeSharingSecretsOutput {
  secrets: AWSJSON!
}

type DecryptedSecretField {
  id: ID!
  key: String!
  value: String!
}

input DeleteIntegrationInput {
  installationId: ID!
  isDeleteInRemoteSourceEnabled: Boolean
}

type DeleteProjectOutput {
  id: ID!
  project: project
}

enum DeployStatusIntegration {
  CREATE_COMPLETE
  DEPLOY_FAILED
  DEPLOY_IN_PROGRESS
  DEPLOY_TIMEOUT
}

type Environment {
  isInUse: Boolean!
  name: String!
}

type GitHubEnvironment {
  id: ID!
  isUsed: Boolean!
  name: String!
}

input GitHubInputZero {
  integrationConnectId: ID!
  projectId: ID!
  secretsIds: [ID!]!
}

input GitHubInstallInputIntegration {
  extra: String!
  vendorProjectName: String!
}

type GitHubProject {
  environments: [GitHubEnvironment!]!
  id: ID!
  name: String!
}

input GitHubProjectsInput {
  integrationConnectId: ID!
  projectId: ID!
}

type GitHubProjectsOutput {
  projects: [GitHubProject!]!
}

input GitHubUpdateSecretsInputIntegration {
  installationId: ID!
}

input GitHubUpdateSecretsInputZero {
  secretsIds: [ID!]!
}

input GitLabInputZero {
  integrationConnectId: ID!
  projectId: ID!
  secretsIds: [ID!]!
}

input GitLabInstallInputIntegration {
  extra: String!
  vendorProjectName: String!
}

type GitLabProject {
  environments: [GitHubEnvironment!]!
  id: ID!
  name: String!
}

input GitLabProjectsInput {
  integrationConnectId: ID!
  projectId: ID!
}

type GitLabProjectsOutput {
  projects: [GitLabProject!]!
}

input GitLabUpdateSecretsInputIntegration {
  installationId: ID!
}

input GitLabUpdateSecretsInputZero {
  secretsIds: [ID!]!
}

input GithubSignInInput {
  code: String!
}

type GithubSignInOutput {
  accessToken: String!
  isNewUser: Boolean!
}

type GoogleAuthLinkOutput {
  url: String!
}

input GoogleSignInInput {
  code: String!
}

type GoogleSignInOutput {
  accessToken: String!
  isNewUser: Boolean!
}

type InsertCliCodeOutput {
  id: ID!
}

type InsertSecretSharingRecordOutput {
  id: ID!
}

type InstallationOutput {
  id: ID!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input IntegrationAWSInstallInputZero {
  integrationConnectId: ID
  operationId: ID
  projectId: ID!
  secretName: String!
  secretsIds: [ID!]!
}

type IntegrationAWSInstallOutput {
  installation: IntegrationAWSInstallOutputInstallation!
}

type IntegrationAWSInstallOutputInstallation {
  id: ID!
}

input LoginInput {
  email: String!
  password: String!
}

input NetlifyInstallInputIntegration {
  extra: String!
  vendorName: String!
}

input NetlifyInstallInputZero {
  integrationConnectId: ID!
  isDownloadSecretsEnabled: Boolean!
  isVendorPriority: Boolean!
  projectId: ID!
  secretsIds: [ID]!
}

type NetlifyInstallOutput {
  installation: NetlifyInstallOutputInstallation!
}

type NetlifyInstallOutputInstallation {
  id: ID!
}

type NetlifyProject {
  environments: [Environment!]!
  id: ID!
  isInUse: Boolean!
  name: String!
}

input NetlifyProjectsInput {
  integrationConnectId: ID!
  projectId: ID!
}

type NetlifyProjectsOutput {
  projects: [NetlifyProject!]!
}

input NetlifyUpdateSecretsInputIntegration {
  buildHookUrl: String
  installationId: ID!
}

input NetlifyUpdateSecretsInputZero {
  secretsIds: [ID]
}

type NetlifyUpdateSecretsOutput {
  errors: [String!]
  installation: InstallationOutput!
  success: Boolean!
}

type RegenerateCredentialProjectTokenOutput {
  credentialProjectToken: credentialToken
  id: ID!
  value: String!
}

type RegenerateProjectTokenOutput {
  id: ID!
  token: token
  value: String!
}

input RegisterInput {
  email: String!
  isMarketingEmailsRequested: Boolean
  password: String!
}

type RejectInvitationOutput {
  id: ID!
}

type RemoveTeamOutput {
  id: ID!
}

type RemoveUserFromTeamOutput {
  teamId: ID!
  userId: ID!
}

type RequestEmailChangeOutput {
  isChanged: Boolean!
}

type RequestResetPasswordOutput {
  isRequested: Boolean!
}

type ResendSignUpEmailOutput {
  email: String!
}

type ResetPasswordOutput {
  isReset: Boolean!
}

type SendEmailToContactUsOutput {
  email: String!
}

type SendInviteUserTeamOutput {
  teamId: ID!
}

type SharingDataOutput {
  id: ID!
  userAvatarUrl: String
  userName: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type SuccessOutput {
  success: Boolean!
}

input TokenObject {
  expiresAt: String
  name: String!
}

type TransferCredentialProjectOutput {
  credentialProject: credentialProject
  id: ID!
}

type UpdateProjectSettingsOutput {
  id: ID!
  project: project
}

type UpdateSecretOutput {
  id: ID!
}

type UpdateSecretsVaultSecretSlugOutput {
  id: ID!
}

type UpdateTeamNameOutput {
  id: ID!
  team: team
}

type UpdateTeamOutput {
  id: ID!
}

type UpdateTeamSlugOutput {
  id: ID!
}

input UpdateUserSecretFieldsInput {
  decryptedValue: String!
  id: ID
  name: String!
}

input VercelInstallInputIntegration {
  extra: String!
  vendorName: String!
}

input VercelInstallInputZero {
  integrationConnectId: ID!
  isDownloadSecretsEnabled: Boolean!
  isVendorPriority: Boolean!
  projectId: ID!
  secretsIds: [ID]!
}

type VercelInstallOutput {
  installation: VercelInstallOutputInstallation!
}

type VercelInstallOutputInstallation {
  id: ID!
}

type VercelProject {
  environments: [Environment!]!
  id: ID!
  isInUse: Boolean!
  name: String!
}

input VercelProjectsInput {
  integrationConnectId: ID!
  projectId: ID!
}

type VercelProjectsOutput {
  projects: [VercelProject!]!
}

input VercelUpdateSecretsInputIntegration {
  buildHookUrl: String
  installationId: ID!
}

input VercelUpdateSecretsInputZero {
  secretsIds: [ID]
}

type VercelUpdateSecretsOutput {
  errors: [String!]
  installation: InstallationOutput!
  success: Boolean!
}

"""User credential projects table from the Zero platform"""
type credentialProject {
  createdAt: timestamptz!

  """An array relationship"""
  credentialSecrets(
    """distinct select on columns"""
    distinct_on: [userCredentialSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecret_order_by!]

    """filter the rows returned"""
    where: userCredentialSecret_bool_exp
  ): [userCredentialSecret!]!

  """An aggregate relationship"""
  credentialSecrets_aggregate(
    """distinct select on columns"""
    distinct_on: [userCredentialSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecret_order_by!]

    """filter the rows returned"""
    where: userCredentialSecret_bool_exp
  ): userCredentialSecret_aggregate!

  """An array relationship"""
  credentialTokens(
    """distinct select on columns"""
    distinct_on: [credentialToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credentialToken_order_by!]

    """filter the rows returned"""
    where: credentialToken_bool_exp
  ): [credentialToken!]!
  description: String!
  icon: String!
  id: uuid!
  lastUpdatedAt: timestamptz!
  name: String!
  slug: String!

  """An object relationship"""
  team: team!
  teamId: uuid!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "credentialProject"
"""
input credentialProject_aggregate_order_by {
  count: order_by
  max: credentialProject_max_order_by
  min: credentialProject_min_order_by
}

"""
Boolean expression to filter rows from the table "credentialProject". All fields are combined with a logical 'AND'.
"""
input credentialProject_bool_exp {
  _and: [credentialProject_bool_exp!]
  _not: credentialProject_bool_exp
  _or: [credentialProject_bool_exp!]
  createdAt: timestamptz_comparison_exp
  credentialSecrets: userCredentialSecret_bool_exp
  credentialSecrets_aggregate: userCredentialSecret_aggregate_bool_exp
  credentialTokens: credentialToken_bool_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  lastUpdatedAt: timestamptz_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
order by max() on columns of table "credentialProject"
"""
input credentialProject_max_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  slug: order_by
  teamId: order_by
  updatedAt: order_by
}

"""
order by min() on columns of table "credentialProject"
"""
input credentialProject_min_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  slug: order_by
  teamId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "credentialProject"
"""
type credentialProject_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [credentialProject!]!
}

"""Ordering options when selecting data from "credentialProject"."""
input credentialProject_order_by {
  createdAt: order_by
  credentialSecrets_aggregate: userCredentialSecret_aggregate_order_by
  credentialTokens_aggregate: credentialToken_aggregate_order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  slug: order_by
  team: team_order_by
  teamId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: credentialProject"""
input credentialProject_pk_columns_input {
  id: uuid!
}

"""
select columns of table "credentialProject"
"""
enum credentialProject_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  teamId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "credentialProject"
"""
input credentialProject_set_input {
  description: String
  icon: String
  name: String
  slug: String
  teamId: uuid
}

"""
Streaming cursor of the table "credentialProject"
"""
input credentialProject_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: credentialProject_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input credentialProject_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  slug: String
  teamId: uuid
  updatedAt: timestamptz
}

input credentialProject_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: credentialProject_set_input

  """filter the rows which have to be updated"""
  where: credentialProject_bool_exp!
}

"""Table for storing credential project tokens."""
type credentialToken {
  createdAt: timestamptz!

  """An object relationship"""
  credentialProject: credentialProject!
  credentialProjectId: uuid!
  expiresAt: timestamptz
  id: uuid!
  name: String!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "credentialToken"
"""
input credentialToken_aggregate_order_by {
  count: order_by
  max: credentialToken_max_order_by
  min: credentialToken_min_order_by
}

"""
Boolean expression to filter rows from the table "credentialToken". All fields are combined with a logical 'AND'.
"""
input credentialToken_bool_exp {
  _and: [credentialToken_bool_exp!]
  _not: credentialToken_bool_exp
  _or: [credentialToken_bool_exp!]
  createdAt: timestamptz_comparison_exp
  credentialProject: credentialProject_bool_exp
  credentialProjectId: uuid_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
order by max() on columns of table "credentialToken"
"""
input credentialToken_max_order_by {
  createdAt: order_by
  credentialProjectId: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
}

"""
order by min() on columns of table "credentialToken"
"""
input credentialToken_min_order_by {
  createdAt: order_by
  credentialProjectId: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "credentialToken"
"""
type credentialToken_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [credentialToken!]!
}

"""Ordering options when selecting data from "credentialToken"."""
input credentialToken_order_by {
  createdAt: order_by
  credentialProject: credentialProject_order_by
  credentialProjectId: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
}

"""primary key columns input for table: credentialToken"""
input credentialToken_pk_columns_input {
  id: uuid!
}

"""
select columns of table "credentialToken"
"""
enum credentialToken_select_column {
  """column name"""
  createdAt

  """column name"""
  credentialProjectId

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updatedAt
}

"""
input type for updating data in table "credentialToken"
"""
input credentialToken_set_input {
  name: String
}

"""
Streaming cursor of the table "credentialToken"
"""
input credentialToken_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: credentialToken_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input credentialToken_stream_cursor_value_input {
  createdAt: timestamptz
  credentialProjectId: uuid
  expiresAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
}

input credentialToken_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: credentialToken_set_input

  """filter the rows which have to be updated"""
  where: credentialToken_bool_exp!
}

enum credentialVendorEnum_enum {
  auth0
  bitbucket
  discord
  dropbox
  figma
  gitHub
  gitLab
  google
  linkedIn
  reddit
  twitter
  zoom
}

"""
Boolean expression to compare columns of type "credentialVendorEnum_enum". All fields are combined with logical 'AND'.
"""
input credentialVendorEnum_enum_comparison_exp {
  _eq: credentialVendorEnum_enum
  _in: [credentialVendorEnum_enum!]
  _is_null: Boolean
  _neq: credentialVendorEnum_enum
  _nin: [credentialVendorEnum_enum!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""doesTeamExistNative Query Arguments"""
input doesTeamExist_arguments {
  """"""
  teamSlug: String!
}

type exists {
  exists: Boolean!
}

"""
Boolean expression to filter rows from the logical model for "exists". All fields are combined with a logical 'AND'.
"""
input exists_bool_exp_bool_exp {
  _and: [exists_bool_exp_bool_exp!]
  _not: exists_bool_exp_bool_exp
  _or: [exists_bool_exp_bool_exp!]
  exists: Boolean_comparison_exp
}

enum exists_enum_name {
  """column name"""
  exists
}

"""Ordering options when selecting data from "exists"."""
input exists_order_by {
  exists: order_by
}

"""
columns and relationships of "integrationConnect"
"""
type integrationConnect {
  id: uuid!

  """An array relationship"""
  installations(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """An aggregate relationship"""
  installations_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!
  name: String!
  userId: uuid!
  vendorName: integrationVendorNameEnum_enum!
}

"""
aggregated selection of "integrationConnect"
"""
type integrationConnect_aggregate {
  aggregate: integrationConnect_aggregate_fields
  nodes: [integrationConnect!]!
}

"""
aggregate fields of "integrationConnect"
"""
type integrationConnect_aggregate_fields {
  count(columns: [integrationConnect_select_column!], distinct: Boolean): Int!
  max: integrationConnect_max_fields
  min: integrationConnect_min_fields
}

"""
Boolean expression to filter rows from the table "integrationConnect". All fields are combined with a logical 'AND'.
"""
input integrationConnect_bool_exp {
  _and: [integrationConnect_bool_exp!]
  _not: integrationConnect_bool_exp
  _or: [integrationConnect_bool_exp!]
  id: uuid_comparison_exp
  installations: integrationInstallation_bool_exp
  installations_aggregate: integrationInstallation_aggregate_bool_exp
  name: String_comparison_exp
  userId: uuid_comparison_exp
  vendorName: integrationVendorNameEnum_enum_comparison_exp
}

"""aggregate max on columns"""
type integrationConnect_max_fields {
  id: uuid
  name: String
  userId: uuid
}

"""aggregate min on columns"""
type integrationConnect_min_fields {
  id: uuid
  name: String
  userId: uuid
}

"""
response of any mutation on the table "integrationConnect"
"""
type integrationConnect_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationConnect!]!
}

"""Ordering options when selecting data from "integrationConnect"."""
input integrationConnect_order_by {
  id: order_by
  installations_aggregate: integrationInstallation_aggregate_order_by
  name: order_by
  userId: order_by
  vendorName: order_by
}

"""primary key columns input for table: integrationConnect"""
input integrationConnect_pk_columns_input {
  id: uuid!
}

"""
select columns of table "integrationConnect"
"""
enum integrationConnect_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  userId

  """column name"""
  vendorName
}

"""
input type for updating data in table "integrationConnect"
"""
input integrationConnect_set_input {
  id: uuid
  name: String
}

"""
Streaming cursor of the table "integrationConnect"
"""
input integrationConnect_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationConnect_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationConnect_stream_cursor_value_input {
  id: uuid
  name: String
  userId: uuid
  vendorName: integrationVendorNameEnum_enum
}

input integrationConnect_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: integrationConnect_set_input

  """filter the rows which have to be updated"""
  where: integrationConnect_bool_exp!
}

"""
Created per each integration installation, should link 3rd party with zero project
"""
type integrationInstallation {
  createdAt: timestamptz!
  extra(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!

  """An object relationship"""
  integrationConnect: integrationConnect!
  integrationConnectId: uuid!
  isSuccessful: Boolean
  name: String

  """An object relationship"""
  project: project!
  projectId: uuid!

  """An array relationship"""
  secrets(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!
  slug: String
  vendorProjectName: String!
}

"""
columns and relationships of "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret {
  id: uuid!

  """An object relationship"""
  integrationInstallation: integrationInstallation!
  integrationInstallationId: uuid!

  """An object relationship"""
  secret: userSecret!
  userSecretId: uuid!
}

"""
order by aggregate values of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_aggregate_order_by {
  count: order_by
  max: integrationInstallationUserSecret_max_order_by
  min: integrationInstallationUserSecret_min_order_by
}

"""
input type for inserting array relation for remote table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_arr_rel_insert_input {
  data: [integrationInstallationUserSecret_insert_input!]!

  """upsert condition"""
  on_conflict: integrationInstallationUserSecret_on_conflict
}

"""
Boolean expression to filter rows from the table "integrationInstallationUserSecret". All fields are combined with a logical 'AND'.
"""
input integrationInstallationUserSecret_bool_exp {
  _and: [integrationInstallationUserSecret_bool_exp!]
  _not: integrationInstallationUserSecret_bool_exp
  _or: [integrationInstallationUserSecret_bool_exp!]
  id: uuid_comparison_exp
  integrationInstallation: integrationInstallation_bool_exp
  integrationInstallationId: uuid_comparison_exp
  secret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "integrationInstallationUserSecret"
"""
enum integrationInstallationUserSecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  integrationInstallationUserSecret_pkey
}

"""
input type for inserting data into table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_insert_input {
  integrationInstallationId: uuid
  secret: userSecret_obj_rel_insert_input
  userSecretId: uuid
}

"""
order by max() on columns of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_max_order_by {
  id: order_by
  integrationInstallationId: order_by
  userSecretId: order_by
}

"""
order by min() on columns of table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_min_order_by {
  id: order_by
  integrationInstallationId: order_by
  userSecretId: order_by
}

"""
response of any mutation on the table "integrationInstallationUserSecret"
"""
type integrationInstallationUserSecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationInstallationUserSecret!]!
}

"""
on_conflict condition type for table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_on_conflict {
  constraint: integrationInstallationUserSecret_constraint!
  update_columns: [integrationInstallationUserSecret_update_column!]! = []
  where: integrationInstallationUserSecret_bool_exp
}

"""
Ordering options when selecting data from "integrationInstallationUserSecret".
"""
input integrationInstallationUserSecret_order_by {
  id: order_by
  integrationInstallation: integrationInstallation_order_by
  integrationInstallationId: order_by
  secret: userSecret_order_by
  userSecretId: order_by
}

"""
select columns of table "integrationInstallationUserSecret"
"""
enum integrationInstallationUserSecret_select_column {
  """column name"""
  id

  """column name"""
  integrationInstallationId

  """column name"""
  userSecretId
}

"""
Streaming cursor of the table "integrationInstallationUserSecret"
"""
input integrationInstallationUserSecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationInstallationUserSecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationInstallationUserSecret_stream_cursor_value_input {
  id: uuid
  integrationInstallationId: uuid
  userSecretId: uuid
}

"""
placeholder for update columns of table "integrationInstallationUserSecret" (current role has no relevant permissions)
"""
enum integrationInstallationUserSecret_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
aggregated selection of "integrationInstallation"
"""
type integrationInstallation_aggregate {
  aggregate: integrationInstallation_aggregate_fields
  nodes: [integrationInstallation!]!
}

input integrationInstallation_aggregate_bool_exp {
  bool_and: integrationInstallation_aggregate_bool_exp_bool_and
  bool_or: integrationInstallation_aggregate_bool_exp_bool_or
  count: integrationInstallation_aggregate_bool_exp_count
}

input integrationInstallation_aggregate_bool_exp_bool_and {
  arguments: integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Boolean_comparison_exp!
}

input integrationInstallation_aggregate_bool_exp_bool_or {
  arguments: integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Boolean_comparison_exp!
}

input integrationInstallation_aggregate_bool_exp_count {
  arguments: [integrationInstallation_select_column!]
  distinct: Boolean
  filter: integrationInstallation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "integrationInstallation"
"""
type integrationInstallation_aggregate_fields {
  count(columns: [integrationInstallation_select_column!], distinct: Boolean): Int!
  max: integrationInstallation_max_fields
  min: integrationInstallation_min_fields
}

"""
order by aggregate values of table "integrationInstallation"
"""
input integrationInstallation_aggregate_order_by {
  count: order_by
  max: integrationInstallation_max_order_by
  min: integrationInstallation_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input integrationInstallation_append_input {
  extra: jsonb
}

"""
Boolean expression to filter rows from the table "integrationInstallation". All fields are combined with a logical 'AND'.
"""
input integrationInstallation_bool_exp {
  _and: [integrationInstallation_bool_exp!]
  _not: integrationInstallation_bool_exp
  _or: [integrationInstallation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  extra: jsonb_comparison_exp
  id: uuid_comparison_exp
  integrationConnect: integrationConnect_bool_exp
  integrationConnectId: uuid_comparison_exp
  isSuccessful: Boolean_comparison_exp
  name: String_comparison_exp
  project: project_bool_exp
  projectId: uuid_comparison_exp
  secrets: integrationInstallationUserSecret_bool_exp
  slug: String_comparison_exp
  vendorProjectName: String_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input integrationInstallation_delete_at_path_input {
  extra: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input integrationInstallation_delete_elem_input {
  extra: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input integrationInstallation_delete_key_input {
  extra: String
}

"""aggregate max on columns"""
type integrationInstallation_max_fields {
  createdAt: timestamptz
  id: uuid
  integrationConnectId: uuid
  name: String
  projectId: uuid
  slug: String
  vendorProjectName: String
}

"""
order by max() on columns of table "integrationInstallation"
"""
input integrationInstallation_max_order_by {
  createdAt: order_by
  id: order_by
  integrationConnectId: order_by
  name: order_by
  projectId: order_by
  slug: order_by
  vendorProjectName: order_by
}

"""aggregate min on columns"""
type integrationInstallation_min_fields {
  createdAt: timestamptz
  id: uuid
  integrationConnectId: uuid
  name: String
  projectId: uuid
  slug: String
  vendorProjectName: String
}

"""
order by min() on columns of table "integrationInstallation"
"""
input integrationInstallation_min_order_by {
  createdAt: order_by
  id: order_by
  integrationConnectId: order_by
  name: order_by
  projectId: order_by
  slug: order_by
  vendorProjectName: order_by
}

"""
response of any mutation on the table "integrationInstallation"
"""
type integrationInstallation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationInstallation!]!
}

"""Ordering options when selecting data from "integrationInstallation"."""
input integrationInstallation_order_by {
  createdAt: order_by
  extra: order_by
  id: order_by
  integrationConnect: integrationConnect_order_by
  integrationConnectId: order_by
  isSuccessful: order_by
  name: order_by
  project: project_order_by
  projectId: order_by
  secrets_aggregate: integrationInstallationUserSecret_aggregate_order_by
  slug: order_by
  vendorProjectName: order_by
}

"""primary key columns input for table: integrationInstallation"""
input integrationInstallation_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input integrationInstallation_prepend_input {
  extra: jsonb
}

"""
select columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column {
  """column name"""
  createdAt

  """column name"""
  extra

  """column name"""
  id

  """column name"""
  integrationConnectId

  """column name"""
  isSuccessful

  """column name"""
  name

  """column name"""
  projectId

  """column name"""
  slug

  """column name"""
  vendorProjectName
}

"""
select "integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns" columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isSuccessful
}

"""
select "integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns" columns of table "integrationInstallation"
"""
enum integrationInstallation_select_column_integrationInstallation_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isSuccessful
}

"""
input type for updating data in table "integrationInstallation"
"""
input integrationInstallation_set_input {
  extra: jsonb
  name: String
}

"""
Streaming cursor of the table "integrationInstallation"
"""
input integrationInstallation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: integrationInstallation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input integrationInstallation_stream_cursor_value_input {
  createdAt: timestamptz
  extra: jsonb
  id: uuid
  integrationConnectId: uuid
  isSuccessful: Boolean
  name: String
  projectId: uuid
  slug: String
  vendorProjectName: String
}

input integrationInstallation_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: integrationInstallation_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: integrationInstallation_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: integrationInstallation_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: integrationInstallation_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: integrationInstallation_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: integrationInstallation_set_input

  """filter the rows which have to be updated"""
  where: integrationInstallation_bool_exp!
}

enum integrationVendorNameEnum_enum {
  aws
  bitbucket
  cloudflare
  gitHub
  gitLab
  netlify
  vercel
}

"""
Boolean expression to compare columns of type "integrationVendorNameEnum_enum". All fields are combined with logical 'AND'.
"""
input integrationVendorNameEnum_enum_comparison_exp {
  _eq: integrationVendorNameEnum_enum
  _in: [integrationVendorNameEnum_enum!]
  _is_null: Boolean
  _neq: integrationVendorNameEnum_enum
  _nin: [integrationVendorNameEnum_enum!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

enum listIdEnum_enum {
  credentials
  integrations
  projects
  secrets
  teams
  users
}

"""
Boolean expression to compare columns of type "listIdEnum_enum". All fields are combined with logical 'AND'.
"""
input listIdEnum_enum_comparison_exp {
  _eq: listIdEnum_enum
  _in: [listIdEnum_enum!]
  _is_null: Boolean
  _neq: listIdEnum_enum
  _nin: [listIdEnum_enum!]
}

"""mutation root"""
type mutation_root {
  acceptInvitation(id: ID!): AcceptInviteOutput!
  awsUpdateSecrets(integrationInstallation: AWSUpdateSecretsInputIntegration!, zero: AWSUpdateSecretsInputZero!): SuccessOutput!
  bitbucketInstall(downloadSecrets: BitbucketDownloadSecretsInput!, integrationInstallation: BitbucketInstallInputIntegration!, zero: BitbucketInputZero!): SuccessOutput!
  bitbucketUpdateSecrets(integrationInstallation: BitbucketUpdateSecretsInputIntegration!, zero: BitbucketUpdateSecretsInputZero!): SuccessOutput!
  changePassword(email: String!, newPassword: String!, oldPassword: String!): ChangePasswordOutput!
  changeTeam(projectId: ID!, teamId: ID!): ChangeTeamOutput!
  cliAccessTokens(object: CliAccessTokensInput!): CliAccessTokensOutput!
  cloudflareAuth(auth: CloudflareAuthInput!): CloudflareAuthOutput!
  cloudflareInstall(downloadSecrets: CloudflareDownloadSecretsInput!, integrationInstallation: CloudflareInstallInputIntegration!, zero: CloudflareInputZero!): SuccessOutput!
  cloudflareUpdateSecrets(integrationInstallation: CloudflareUpdateSecretsInputIntegration!, zero: CloudflareUpdateSecretsInputZero!): SuccessOutput!
  confirmEmailChange(code: String!): ConfirmEmailChangeOutput!
  createCredentialProject(icon: String!, name: String!, teamId: ID!, token: TokenObject!): CreateCredentialProjectOutput!
  createCredentialProjectToken(object: CreateCredentialProjectTokenInput!): CreateCredentialProjectTokenOutput!
  createProject(icon: String!, name: String!, teamId: ID!, token: TokenObject): CreateProjectOutput!
  createProjectToken(object: CreateProjectTokenInput!): CreateProjectTokenOutput!
  createSecret(fields: [CreateSecretFieldInput!]!, secret: CreateSecretInput!): CreateSecretOutput!
  createTeam(name: String!, slug: String!): CreateTeamOutput!
  decodeSharingSecrets(id: ID!, passphrase: String!): DecodeSharingSecretsOutput!
  deleteIntegration(integrationInstallation: DeleteIntegrationInput!): SuccessOutput!
  deleteProject(id: ID!, isVendorSecretsMarkedAsDeleted: Boolean!): DeleteProjectOutput!

  """
  delete data from the table: "credentialProject"
  """
  delete_credentialProject(
    """filter the rows which have to be deleted"""
    where: credentialProject_bool_exp!
  ): credentialProject_mutation_response

  """
  delete single row from the table: "credentialProject"
  """
  delete_credentialProject_by_pk(id: uuid!): credentialProject

  """
  delete data from the table: "credentialToken"
  """
  delete_credentialToken(
    """filter the rows which have to be deleted"""
    where: credentialToken_bool_exp!
  ): credentialToken_mutation_response

  """
  delete single row from the table: "credentialToken"
  """
  delete_credentialToken_by_pk(id: uuid!): credentialToken

  """
  delete data from the table: "integrationConnect"
  """
  delete_integrationConnect(
    """filter the rows which have to be deleted"""
    where: integrationConnect_bool_exp!
  ): integrationConnect_mutation_response

  """
  delete single row from the table: "integrationConnect"
  """
  delete_integrationConnect_by_pk(id: uuid!): integrationConnect

  """
  delete data from the table: "integrationInstallation"
  """
  delete_integrationInstallation(
    """filter the rows which have to be deleted"""
    where: integrationInstallation_bool_exp!
  ): integrationInstallation_mutation_response

  """
  delete data from the table: "integrationInstallationUserSecret"
  """
  delete_integrationInstallationUserSecret(
    """filter the rows which have to be deleted"""
    where: integrationInstallationUserSecret_bool_exp!
  ): integrationInstallationUserSecret_mutation_response

  """
  delete single row from the table: "integrationInstallationUserSecret"
  """
  delete_integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  delete single row from the table: "integrationInstallation"
  """
  delete_integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """
  delete data from the table: "team"
  """
  delete_team(
    """filter the rows which have to be deleted"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  delete data from the table: "teamInvitation"
  """
  delete_teamInvitation(
    """filter the rows which have to be deleted"""
    where: teamInvitation_bool_exp!
  ): teamInvitation_mutation_response

  """
  delete single row from the table: "teamInvitation"
  """
  delete_teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  delete single row from the table: "team"
  """
  delete_team_by_pk(id: uuid!): team

  """
  delete data from the table: "token"
  """
  delete_token(
    """filter the rows which have to be deleted"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  delete single row from the table: "token"
  """
  delete_token_by_pk(id: uuid!): token

  """
  delete data from the table: "userCredentialSecret"
  """
  delete_userCredentialSecret(
    """filter the rows which have to be deleted"""
    where: userCredentialSecret_bool_exp!
  ): userCredentialSecret_mutation_response

  """
  delete data from the table: "userCredentialSecretField"
  """
  delete_userCredentialSecretField(
    """filter the rows which have to be deleted"""
    where: userCredentialSecretField_bool_exp!
  ): userCredentialSecretField_mutation_response

  """
  delete single row from the table: "userCredentialSecretField"
  """
  delete_userCredentialSecretField_by_pk(id: uuid!): userCredentialSecretField

  """
  delete single row from the table: "userCredentialSecret"
  """
  delete_userCredentialSecret_by_pk(id: uuid!): userCredentialSecret

  """
  delete data from the table: "userSecret"
  """
  delete_userSecret(
    """filter the rows which have to be deleted"""
    where: userSecret_bool_exp!
  ): userSecret_mutation_response

  """
  delete data from the table: "userSecretField"
  """
  delete_userSecretField(
    """filter the rows which have to be deleted"""
    where: userSecretField_bool_exp!
  ): userSecretField_mutation_response

  """
  delete single row from the table: "userSecretField"
  """
  delete_userSecretField_by_pk(id: uuid!): userSecretField

  """
  delete single row from the table: "userSecret"
  """
  delete_userSecret_by_pk(id: uuid!): userSecret
  githubInstall(integrationInstallation: GitHubInstallInputIntegration!, zero: GitHubInputZero!): SuccessOutput!
  githubSignIn(object: GithubSignInInput!): GithubSignInOutput!
  githubUpdateSecrets(integrationInstallation: GitHubUpdateSecretsInputIntegration!, zero: GitHubUpdateSecretsInputZero!): SuccessOutput!
  gitlabInstall(integrationInstallation: GitLabInstallInputIntegration!, zero: GitLabInputZero!): SuccessOutput!
  gitlabUpdateSecrets(integrationInstallation: GitLabUpdateSecretsInputIntegration!, zero: GitLabUpdateSecretsInputZero!): SuccessOutput!
  googleAuthLink(state: String!): GoogleAuthLinkOutput!
  googleSignIn(object: GoogleSignInInput!): GoogleSignInOutput!
  insertCliCode(code: String!): InsertCliCodeOutput!
  insertSecretSharingRecord(expiresAt: String!, passphrase: String!, secretsFieldIds: [ID!]!): InsertSecretSharingRecordOutput!

  """
  insert data into the table: "integrationInstallationUserSecret"
  """
  insert_integrationInstallationUserSecret(
    """the rows to be inserted"""
    objects: [integrationInstallationUserSecret_insert_input!]!

    """upsert condition"""
    on_conflict: integrationInstallationUserSecret_on_conflict
  ): integrationInstallationUserSecret_mutation_response

  """
  insert a single row into the table: "integrationInstallationUserSecret"
  """
  insert_integrationInstallationUserSecret_one(
    """the row to be inserted"""
    object: integrationInstallationUserSecret_insert_input!

    """upsert condition"""
    on_conflict: integrationInstallationUserSecret_on_conflict
  ): integrationInstallationUserSecret

  """
  insert data into the table: "notification"
  """
  insert_notification(
    """the rows to be inserted"""
    objects: [notification_insert_input!]!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  """
  insert data into the table: "notificationUser"
  """
  insert_notificationUser(
    """the rows to be inserted"""
    objects: [notificationUser_insert_input!]!

    """upsert condition"""
    on_conflict: notificationUser_on_conflict
  ): notificationUser_mutation_response

  """
  insert a single row into the table: "notificationUser"
  """
  insert_notificationUser_one(
    """the row to be inserted"""
    object: notificationUser_insert_input!

    """upsert condition"""
    on_conflict: notificationUser_on_conflict
  ): notificationUser

  """
  insert a single row into the table: "notification"
  """
  insert_notification_one(
    """the row to be inserted"""
    object: notification_insert_input!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification

  """
  insert data into the table: "teamInvitation"
  """
  insert_teamInvitation(
    """the rows to be inserted"""
    objects: [teamInvitation_insert_input!]!

    """upsert condition"""
    on_conflict: teamInvitation_on_conflict
  ): teamInvitation_mutation_response

  """
  insert a single row into the table: "teamInvitation"
  """
  insert_teamInvitation_one(
    """the row to be inserted"""
    object: teamInvitation_insert_input!

    """upsert condition"""
    on_conflict: teamInvitation_on_conflict
  ): teamInvitation

  """
  insert data into the table: "teamUser"
  """
  insert_teamUser(
    """the rows to be inserted"""
    objects: [teamUser_insert_input!]!

    """upsert condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser_mutation_response

  """
  insert a single row into the table: "teamUser"
  """
  insert_teamUser_one(
    """the row to be inserted"""
    object: teamUser_insert_input!

    """upsert condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser

  """
  insert data into the table: "userCredentialSecret"
  """
  insert_userCredentialSecret(
    """the rows to be inserted"""
    objects: [userCredentialSecret_insert_input!]!

    """upsert condition"""
    on_conflict: userCredentialSecret_on_conflict
  ): userCredentialSecret_mutation_response

  """
  insert data into the table: "userCredentialSecretField"
  """
  insert_userCredentialSecretField(
    """the rows to be inserted"""
    objects: [userCredentialSecretField_insert_input!]!

    """upsert condition"""
    on_conflict: userCredentialSecretField_on_conflict
  ): userCredentialSecretField_mutation_response

  """
  insert a single row into the table: "userCredentialSecretField"
  """
  insert_userCredentialSecretField_one(
    """the row to be inserted"""
    object: userCredentialSecretField_insert_input!

    """upsert condition"""
    on_conflict: userCredentialSecretField_on_conflict
  ): userCredentialSecretField

  """
  insert a single row into the table: "userCredentialSecret"
  """
  insert_userCredentialSecret_one(
    """the row to be inserted"""
    object: userCredentialSecret_insert_input!

    """upsert condition"""
    on_conflict: userCredentialSecret_on_conflict
  ): userCredentialSecret

  """
  insert data into the table: "userSecret"
  """
  insert_userSecret(
    """the rows to be inserted"""
    objects: [userSecret_insert_input!]!

    """upsert condition"""
    on_conflict: userSecret_on_conflict
  ): userSecret_mutation_response

  """
  insert data into the table: "userSecretField"
  """
  insert_userSecretField(
    """the rows to be inserted"""
    objects: [userSecretField_insert_input!]!

    """upsert condition"""
    on_conflict: userSecretField_on_conflict
  ): userSecretField_mutation_response

  """
  insert a single row into the table: "userSecretField"
  """
  insert_userSecretField_one(
    """the row to be inserted"""
    object: userSecretField_insert_input!

    """upsert condition"""
    on_conflict: userSecretField_on_conflict
  ): userSecretField

  """
  insert a single row into the table: "userSecret"
  """
  insert_userSecret_one(
    """the row to be inserted"""
    object: userSecret_insert_input!

    """upsert condition"""
    on_conflict: userSecret_on_conflict
  ): userSecret

  """
  insert data into the table: "viewPreferences"
  """
  insert_viewPreferences(
    """the rows to be inserted"""
    objects: [viewPreferences_insert_input!]!

    """upsert condition"""
    on_conflict: viewPreferences_on_conflict
  ): viewPreferences_mutation_response

  """
  insert a single row into the table: "viewPreferences"
  """
  insert_viewPreferences_one(
    """the row to be inserted"""
    object: viewPreferences_insert_input!

    """upsert condition"""
    on_conflict: viewPreferences_on_conflict
  ): viewPreferences
  integrationAWSInstall(zero: IntegrationAWSInstallInputZero!): IntegrationAWSInstallOutput!

  """Login api action"""
  login(object: LoginInput!): SuccessOutput!

  """Logout action from the webapp"""
  logout: SuccessOutput!
  netlifyInstall(integrationInstallation: NetlifyInstallInputIntegration!, zero: NetlifyInstallInputZero!): NetlifyInstallOutput!
  netlifyUpdateSecrets(integrationInstallation: NetlifyUpdateSecretsInputIntegration!, zero: NetlifyUpdateSecretsInputZero!): NetlifyUpdateSecretsOutput!
  regenerateCredentialProjectToken(expiresAt: String, id: ID!): RegenerateCredentialProjectTokenOutput!
  regenerateProjectToken(expiresAt: String, id: ID!): RegenerateProjectTokenOutput!

  """Register api action"""
  register(object: RegisterInput!): SuccessOutput!
  rejectInvitation(id: ID!): RejectInvitationOutput!
  removeTeam(teamId: ID!): RemoveTeamOutput!
  removeUserFromTeam(teamId: ID!, userId: ID!): RemoveUserFromTeamOutput!
  requestEmailChange(newEmail: String!): RequestEmailChangeOutput!
  requestResetPassword(email: String!, isReset: Boolean!): RequestResetPasswordOutput!
  resendSignUpEmail: ResendSignUpEmailOutput!
  resetPassword(code: String!, newPassword: String!): ResetPasswordOutput!
  sendEmailToContactUs(email: String!, message: String!, name: String!): SendEmailToContactUsOutput!
  sendInviteUserTeam(email: String!, teamId: ID!): SendInviteUserTeamOutput!
  transferCredentialProject(projectId: ID!, teamId: ID!): TransferCredentialProjectOutput!
  updateProjectSettings(icon: String!, id: ID!, name: String!, slug: String!, teamId: ID!): UpdateProjectSettingsOutput!
  updateSecret(fields: [UpdateUserSecretFieldsInput!]!, id: ID!, name: String!, slug: String!): UpdateSecretOutput!
  updateSecretsVaultSecretSlug(id: ID!, slug: String!): UpdateSecretsVaultSecretSlugOutput!
  updateTeam(id: ID!, name: String!, slug: String!): UpdateTeamOutput!
  updateTeamName(id: ID!, name: String!): UpdateTeamNameOutput!
  updateTeamSlug(id: ID!, slug: String!): UpdateTeamSlugOutput!

  """
  update data of the table: "credentialProject"
  """
  update_credentialProject(
    """sets the columns of the filtered rows to the given values"""
    _set: credentialProject_set_input

    """filter the rows which have to be updated"""
    where: credentialProject_bool_exp!
  ): credentialProject_mutation_response

  """
  update single row of the table: "credentialProject"
  """
  update_credentialProject_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: credentialProject_set_input
    pk_columns: credentialProject_pk_columns_input!
  ): credentialProject

  """
  update multiples rows of table: "credentialProject"
  """
  update_credentialProject_many(
    """updates to execute, in order"""
    updates: [credentialProject_updates!]!
  ): [credentialProject_mutation_response]

  """
  update data of the table: "credentialToken"
  """
  update_credentialToken(
    """sets the columns of the filtered rows to the given values"""
    _set: credentialToken_set_input

    """filter the rows which have to be updated"""
    where: credentialToken_bool_exp!
  ): credentialToken_mutation_response

  """
  update single row of the table: "credentialToken"
  """
  update_credentialToken_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: credentialToken_set_input
    pk_columns: credentialToken_pk_columns_input!
  ): credentialToken

  """
  update multiples rows of table: "credentialToken"
  """
  update_credentialToken_many(
    """updates to execute, in order"""
    updates: [credentialToken_updates!]!
  ): [credentialToken_mutation_response]

  """
  update data of the table: "integrationConnect"
  """
  update_integrationConnect(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationConnect_set_input

    """filter the rows which have to be updated"""
    where: integrationConnect_bool_exp!
  ): integrationConnect_mutation_response

  """
  update single row of the table: "integrationConnect"
  """
  update_integrationConnect_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationConnect_set_input
    pk_columns: integrationConnect_pk_columns_input!
  ): integrationConnect

  """
  update multiples rows of table: "integrationConnect"
  """
  update_integrationConnect_many(
    """updates to execute, in order"""
    updates: [integrationConnect_updates!]!
  ): [integrationConnect_mutation_response]

  """
  update data of the table: "integrationInstallation"
  """
  update_integrationInstallation(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integrationInstallation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integrationInstallation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integrationInstallation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integrationInstallation_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integrationInstallation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallation_set_input

    """filter the rows which have to be updated"""
    where: integrationInstallation_bool_exp!
  ): integrationInstallation_mutation_response

  """
  update single row of the table: "integrationInstallation"
  """
  update_integrationInstallation_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: integrationInstallation_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: integrationInstallation_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: integrationInstallation_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: integrationInstallation_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: integrationInstallation_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: integrationInstallation_set_input
    pk_columns: integrationInstallation_pk_columns_input!
  ): integrationInstallation

  """
  update multiples rows of table: "integrationInstallation"
  """
  update_integrationInstallation_many(
    """updates to execute, in order"""
    updates: [integrationInstallation_updates!]!
  ): [integrationInstallation_mutation_response]

  """
  update data of the table: "notification"
  """
  update_notification(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input

    """filter the rows which have to be updated"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  update single row of the table: "notification"
  """
  update_notification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  """
  update multiples rows of table: "notification"
  """
  update_notification_many(
    """updates to execute, in order"""
    updates: [notification_updates!]!
  ): [notification_mutation_response]

  """
  update data of the table: "project"
  """
  update_project(
    """sets the columns of the filtered rows to the given values"""
    _set: project_set_input

    """filter the rows which have to be updated"""
    where: project_bool_exp!
  ): project_mutation_response

  """
  update single row of the table: "project"
  """
  update_project_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: project_set_input
    pk_columns: project_pk_columns_input!
  ): project

  """
  update multiples rows of table: "project"
  """
  update_project_many(
    """updates to execute, in order"""
    updates: [project_updates!]!
  ): [project_mutation_response]

  """
  update data of the table: "team"
  """
  update_team(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input

    """filter the rows which have to be updated"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  update data of the table: "teamInvitation"
  """
  update_teamInvitation(
    """sets the columns of the filtered rows to the given values"""
    _set: teamInvitation_set_input

    """filter the rows which have to be updated"""
    where: teamInvitation_bool_exp!
  ): teamInvitation_mutation_response

  """
  update single row of the table: "teamInvitation"
  """
  update_teamInvitation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: teamInvitation_set_input
    pk_columns: teamInvitation_pk_columns_input!
  ): teamInvitation

  """
  update multiples rows of table: "teamInvitation"
  """
  update_teamInvitation_many(
    """updates to execute, in order"""
    updates: [teamInvitation_updates!]!
  ): [teamInvitation_mutation_response]

  """
  update data of the table: "teamUser"
  """
  update_teamUser(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input

    """filter the rows which have to be updated"""
    where: teamUser_bool_exp!
  ): teamUser_mutation_response

  """
  update single row of the table: "teamUser"
  """
  update_teamUser_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input
    pk_columns: teamUser_pk_columns_input!
  ): teamUser

  """
  update multiples rows of table: "teamUser"
  """
  update_teamUser_many(
    """updates to execute, in order"""
    updates: [teamUser_updates!]!
  ): [teamUser_mutation_response]

  """
  update single row of the table: "team"
  """
  update_team_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input
    pk_columns: team_pk_columns_input!
  ): team

  """
  update multiples rows of table: "team"
  """
  update_team_many(
    """updates to execute, in order"""
    updates: [team_updates!]!
  ): [team_mutation_response]

  """
  update data of the table: "token"
  """
  update_token(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input

    """filter the rows which have to be updated"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  update single row of the table: "token"
  """
  update_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input
    pk_columns: token_pk_columns_input!
  ): token

  """
  update multiples rows of table: "token"
  """
  update_token_many(
    """updates to execute, in order"""
    updates: [token_updates!]!
  ): [token_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update data of the table: "userCredentialSecret"
  """
  update_userCredentialSecret(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: userCredentialSecret_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: userCredentialSecret_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: userCredentialSecret_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: userCredentialSecret_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: userCredentialSecret_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: userCredentialSecret_set_input

    """filter the rows which have to be updated"""
    where: userCredentialSecret_bool_exp!
  ): userCredentialSecret_mutation_response

  """
  update data of the table: "userCredentialSecretField"
  """
  update_userCredentialSecretField(
    """sets the columns of the filtered rows to the given values"""
    _set: userCredentialSecretField_set_input

    """filter the rows which have to be updated"""
    where: userCredentialSecretField_bool_exp!
  ): userCredentialSecretField_mutation_response

  """
  update single row of the table: "userCredentialSecretField"
  """
  update_userCredentialSecretField_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userCredentialSecretField_set_input
    pk_columns: userCredentialSecretField_pk_columns_input!
  ): userCredentialSecretField

  """
  update multiples rows of table: "userCredentialSecretField"
  """
  update_userCredentialSecretField_many(
    """updates to execute, in order"""
    updates: [userCredentialSecretField_updates!]!
  ): [userCredentialSecretField_mutation_response]

  """
  update single row of the table: "userCredentialSecret"
  """
  update_userCredentialSecret_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: userCredentialSecret_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: userCredentialSecret_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: userCredentialSecret_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: userCredentialSecret_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: userCredentialSecret_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: userCredentialSecret_set_input
    pk_columns: userCredentialSecret_pk_columns_input!
  ): userCredentialSecret

  """
  update multiples rows of table: "userCredentialSecret"
  """
  update_userCredentialSecret_many(
    """updates to execute, in order"""
    updates: [userCredentialSecret_updates!]!
  ): [userCredentialSecret_mutation_response]

  """
  update data of the table: "userSecret"
  """
  update_userSecret(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: userSecret_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: userSecret_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: userSecret_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: userSecret_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: userSecret_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: userSecret_set_input

    """filter the rows which have to be updated"""
    where: userSecret_bool_exp!
  ): userSecret_mutation_response

  """
  update data of the table: "userSecretField"
  """
  update_userSecretField(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecretField_set_input

    """filter the rows which have to be updated"""
    where: userSecretField_bool_exp!
  ): userSecretField_mutation_response

  """
  update single row of the table: "userSecretField"
  """
  update_userSecretField_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: userSecretField_set_input
    pk_columns: userSecretField_pk_columns_input!
  ): userSecretField

  """
  update multiples rows of table: "userSecretField"
  """
  update_userSecretField_many(
    """updates to execute, in order"""
    updates: [userSecretField_updates!]!
  ): [userSecretField_mutation_response]

  """
  update single row of the table: "userSecret"
  """
  update_userSecret_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: userSecret_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: userSecret_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: userSecret_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: userSecret_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: userSecret_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: userSecret_set_input
    pk_columns: userSecret_pk_columns_input!
  ): userSecret

  """
  update multiples rows of table: "userSecret"
  """
  update_userSecret_many(
    """updates to execute, in order"""
    updates: [userSecret_updates!]!
  ): [userSecret_mutation_response]

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]

  """
  update data of the table: "viewPreferences"
  """
  update_viewPreferences(
    """sets the columns of the filtered rows to the given values"""
    _set: viewPreferences_set_input

    """filter the rows which have to be updated"""
    where: viewPreferences_bool_exp!
  ): viewPreferences_mutation_response

  """
  update single row of the table: "viewPreferences"
  """
  update_viewPreferences_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: viewPreferences_set_input
    pk_columns: viewPreferences_pk_columns_input!
  ): viewPreferences

  """
  update multiples rows of table: "viewPreferences"
  """
  update_viewPreferences_many(
    """updates to execute, in order"""
    updates: [viewPreferences_updates!]!
  ): [viewPreferences_mutation_response]
  vercelInstall(integrationInstallation: VercelInstallInputIntegration!, zero: VercelInstallInputZero!): VercelInstallOutput!
  vercelUpdateSecrets(integrationInstallation: VercelUpdateSecretsInputIntegration!, zero: VercelUpdateSecretsInputZero!): VercelUpdateSecretsOutput!
}

"""
columns and relationships of "notification"
"""
type notification {
  createdAt: timestamp!
  id: uuid!
  isViewed: Boolean!
  message: String!
  updatedAt: timestamp!

  """An object relationship"""
  user: user!
  userId: uuid!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!
}

"""
columns and relationships of "notificationUser"
"""
type notificationUser {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  notification: notification!
  notificationId: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  user: user!
  userId: uuid!
}

"""
order by aggregate values of table "notificationUser"
"""
input notificationUser_aggregate_order_by {
  count: order_by
  max: notificationUser_max_order_by
  min: notificationUser_min_order_by
}

"""
input type for inserting array relation for remote table "notificationUser"
"""
input notificationUser_arr_rel_insert_input {
  data: [notificationUser_insert_input!]!

  """upsert condition"""
  on_conflict: notificationUser_on_conflict
}

"""
Boolean expression to filter rows from the table "notificationUser". All fields are combined with a logical 'AND'.
"""
input notificationUser_bool_exp {
  _and: [notificationUser_bool_exp!]
  _not: notificationUser_bool_exp
  _or: [notificationUser_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notification: notification_bool_exp
  notificationId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notificationUser"
"""
enum notificationUser_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notificationUser_pkey
}

"""
input type for inserting data into table "notificationUser"
"""
input notificationUser_insert_input {
  notification: notification_obj_rel_insert_input
  notificationId: uuid
  userId: uuid
}

"""
order by max() on columns of table "notificationUser"
"""
input notificationUser_max_order_by {
  createdAt: order_by
  id: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
order by min() on columns of table "notificationUser"
"""
input notificationUser_min_order_by {
  createdAt: order_by
  id: order_by
  notificationId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "notificationUser"
"""
type notificationUser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notificationUser!]!
}

"""
on_conflict condition type for table "notificationUser"
"""
input notificationUser_on_conflict {
  constraint: notificationUser_constraint!
  update_columns: [notificationUser_update_column!]! = []
  where: notificationUser_bool_exp
}

"""Ordering options when selecting data from "notificationUser"."""
input notificationUser_order_by {
  createdAt: order_by
  id: order_by
  notification: notification_order_by
  notificationId: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
}

"""
select columns of table "notificationUser"
"""
enum notificationUser_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  notificationId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
Streaming cursor of the table "notificationUser"
"""
input notificationUser_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notificationUser_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notificationUser_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  notificationId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
placeholder for update columns of table "notificationUser" (current role has no relevant permissions)
"""
enum notificationUser_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
order by aggregate values of table "notification"
"""
input notification_aggregate_order_by {
  count: order_by
  max: notification_max_order_by
  min: notification_min_order_by
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input notification_bool_exp {
  _and: [notification_bool_exp!]
  _not: notification_bool_exp
  _or: [notification_bool_exp!]
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  isViewed: Boolean_comparison_exp
  message: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
  users: notificationUser_bool_exp
}

"""
unique or primary key constraints on table "notification"
"""
enum notification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_pkey
}

"""
input type for inserting data into table "notification"
"""
input notification_insert_input {
  message: String
  userId: uuid
  users: notificationUser_arr_rel_insert_input
}

"""
order by max() on columns of table "notification"
"""
input notification_max_order_by {
  createdAt: order_by
  id: order_by
  message: order_by
  updatedAt: order_by
  userId: order_by
}

"""
order by min() on columns of table "notification"
"""
input notification_min_order_by {
  createdAt: order_by
  id: order_by
  message: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "notification"
"""
type notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification!]!
}

"""
input type for inserting object relation for remote table "notification"
"""
input notification_obj_rel_insert_input {
  data: notification_insert_input!

  """upsert condition"""
  on_conflict: notification_on_conflict
}

"""
on_conflict condition type for table "notification"
"""
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]! = []
  where: notification_bool_exp
}

"""Ordering options when selecting data from "notification"."""
input notification_order_by {
  createdAt: order_by
  id: order_by
  isViewed: order_by
  message: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
  users_aggregate: notificationUser_aggregate_order_by
}

"""primary key columns input for table: notification"""
input notification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notification"
"""
enum notification_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isViewed

  """column name"""
  message

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "notification"
"""
input notification_set_input {
  isViewed: Boolean
}

"""
Streaming cursor of the table "notification"
"""
input notification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_stream_cursor_value_input {
  createdAt: timestamp
  id: uuid
  isViewed: Boolean
  message: String
  updatedAt: timestamp
  userId: uuid
}

"""
update columns of table "notification"
"""
enum notification_update_column {
  """column name"""
  isViewed
}

input notification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notification_set_input

  """filter the rows which have to be updated"""
  where: notification_bool_exp!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""Table of user projects created in Zero."""
type project {
  createdAt: timestamptz!
  description: String!
  icon: String!
  id: uuid!

  """An array relationship"""
  integrationInstallations(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """An aggregate relationship"""
  integrationInstallations_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!
  lastUpdatedAt: timestamptz!

  """
  A computed field, executes function "computeProjectLastUsedAt"
  """
  lastUsedAt: timestamptz
  name: String!
  slug: String!

  """An object relationship"""
  team: team!
  teamId: uuid!

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!
  updatedAt: timestamptz!

  """An array relationship"""
  usageHistories(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """An aggregate relationship"""
  usageHistories_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """An array relationship"""
  userSecrets(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """An aggregate relationship"""
  userSecrets_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!
}

"""
order by aggregate values of table "project"
"""
input project_aggregate_order_by {
  count: order_by
  max: project_max_order_by
  min: project_min_order_by
}

"""
Boolean expression to filter rows from the table "project". All fields are combined with a logical 'AND'.
"""
input project_bool_exp {
  _and: [project_bool_exp!]
  _not: project_bool_exp
  _or: [project_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  integrationInstallations: integrationInstallation_bool_exp
  integrationInstallations_aggregate: integrationInstallation_aggregate_bool_exp
  lastUpdatedAt: timestamptz_comparison_exp
  lastUsedAt: timestamptz_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  tokens: token_bool_exp
  updatedAt: timestamptz_comparison_exp
  usageHistories: usageHistory_bool_exp
  usageHistories_aggregate: usageHistory_aggregate_bool_exp
  userSecrets: userSecret_bool_exp
  userSecrets_aggregate: userSecret_aggregate_bool_exp
}

"""
order by max() on columns of table "project"
"""
input project_max_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  slug: order_by
  teamId: order_by
  updatedAt: order_by
}

"""
order by min() on columns of table "project"
"""
input project_min_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  slug: order_by
  teamId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "project"
"""
type project_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [project!]!
}

"""Ordering options when selecting data from "project"."""
input project_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  integrationInstallations_aggregate: integrationInstallation_aggregate_order_by
  lastUpdatedAt: order_by
  lastUsedAt: order_by
  name: order_by
  slug: order_by
  team: team_order_by
  teamId: order_by
  tokens_aggregate: token_aggregate_order_by
  updatedAt: order_by
  usageHistories_aggregate: usageHistory_aggregate_order_by
  userSecrets_aggregate: userSecret_aggregate_order_by
}

"""primary key columns input for table: project"""
input project_pk_columns_input {
  id: uuid!
}

"""
select columns of table "project"
"""
enum project_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  teamId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "project"
"""
input project_set_input {
  description: String
  icon: String
  name: String
  slug: String
  teamId: uuid
}

"""
Streaming cursor of the table "project"
"""
input project_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: project_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input project_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  icon: String
  id: uuid
  lastUpdatedAt: timestamptz
  name: String
  slug: String
  teamId: uuid
  updatedAt: timestamptz
}

input project_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: project_set_input

  """filter the rows which have to be updated"""
  where: project_bool_exp!
}

type query_root {
  bitbucketWorkspaceProjects(where: BitbucketWorkspaceProjectsInput!): BitbucketWorkspaceProjectsOutput!
  checkIntegrationDeploy(integrationConnect: CheckIntegrationDeployInput!): CheckIntegrationDeployOutput!
  checkUserEmailExist(email: String!): CheckUserEmailExistOutput!
  cloudflareProjects(where: CloudflareProjectsInput!): CloudflareProjectsOutput!

  """
  fetch data from the table: "credentialProject"
  """
  credentialProject(
    """distinct select on columns"""
    distinct_on: [credentialProject_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credentialProject_order_by!]

    """filter the rows returned"""
    where: credentialProject_bool_exp
  ): [credentialProject!]!

  """
  fetch data from the table: "credentialProject" using primary key columns
  """
  credentialProject_by_pk(id: uuid!): credentialProject

  """
  fetch data from the table: "credentialToken"
  """
  credentialToken(
    """distinct select on columns"""
    distinct_on: [credentialToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credentialToken_order_by!]

    """filter the rows returned"""
    where: credentialToken_bool_exp
  ): [credentialToken!]!

  """fetch data from the table: "credentialToken" using primary key columns"""
  credentialToken_by_pk(id: uuid!): credentialToken
  doesTeamExist(
    """doesTeamExistNative Query Arguments"""
    args: doesTeamExist_arguments!

    """distinct select on columns"""
    distinct_on: [exists_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exists_order_by!]

    """filter the rows returned"""
    where: exists_bool_exp_bool_exp
  ): [exists!]!
  githubProjects(where: GitHubProjectsInput!): GitHubProjectsOutput!
  gitlabProjects(where: GitLabProjectsInput!): GitLabProjectsOutput!

  """
  fetch data from the table: "integrationConnect"
  """
  integrationConnect(
    """distinct select on columns"""
    distinct_on: [integrationConnect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationConnect_order_by!]

    """filter the rows returned"""
    where: integrationConnect_bool_exp
  ): [integrationConnect!]!

  """
  fetch aggregated fields from the table: "integrationConnect"
  """
  integrationConnect_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationConnect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationConnect_order_by!]

    """filter the rows returned"""
    where: integrationConnect_bool_exp
  ): integrationConnect_aggregate!

  """
  fetch data from the table: "integrationConnect" using primary key columns
  """
  integrationConnect_by_pk(id: uuid!): integrationConnect

  """
  fetch data from the table: "integrationInstallation"
  """
  integrationInstallation(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch data from the table: "integrationInstallationUserSecret" using primary key columns
  """
  integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  fetch aggregated fields from the table: "integrationInstallation"
  """
  integrationInstallation_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!

  """
  fetch data from the table: "integrationInstallation" using primary key columns
  """
  integrationInstallation_by_pk(id: uuid!): integrationInstallation
  netlifyProjects(where: NetlifyProjectsInput!): NetlifyProjectsOutput!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "notificationUser"
  """
  notificationUser(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """
  fetch data from the table: "notificationUser" using primary key columns
  """
  notificationUser_by_pk(id: uuid!): notificationUser

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table: "project"
  """
  project(
    """distinct select on columns"""
    distinct_on: [project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): [project!]!

  """fetch data from the table: "project" using primary key columns"""
  project_by_pk(id: uuid!): project

  """
  execute function "search_token_by_id" which returns "token"
  """
  search_token_by_id(
    """
    input parameters for function "search_token_by_id"
    """
    args: search_token_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  execute function "search_usage_history_by_id" which returns "usageHistory"
  """
  search_usage_history_by_id(
    """
    input parameters for function "search_usage_history_by_id"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  execute function "search_usage_history_by_id" and query aggregates on result of table type "usageHistory"
  """
  search_usage_history_by_id_aggregate(
    """
    input parameters for function "search_usage_history_by_id_aggregate"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """
  execute function "search_user_by_id" which returns "user"
  """
  search_user_by_id(
    """
    input parameters for function "search_user_by_id"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
  sharingData(id: ID!): SharingDataOutput

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "teamInvitation"
  """
  teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """fetch data from the table: "teamInvitation" using primary key columns"""
  teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  fetch data from the table: "teamUser"
  """
  teamUser(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "teamUser"
  """
  teamUser_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """fetch data from the table: "teamUser" using primary key columns"""
  teamUser_by_pk(id: uuid!): teamUser

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """
  fetch data from the table: "usageHistory"
  """
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "usageHistorySecret"
  """
  usageHistorySecret(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """
  fetch aggregated fields from the table: "usageHistorySecret"
  """
  usageHistorySecret_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """
  fetch data from the table: "usageHistorySecret" using primary key columns
  """
  usageHistorySecret_by_pk(id: uuid!): usageHistorySecret

  """
  fetch aggregated fields from the table: "usageHistory"
  """
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """fetch data from the table: "usageHistory" using primary key columns"""
  usageHistory_by_pk(id: uuid!): usageHistory

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "userCredentialSecret"
  """
  userCredentialSecret(
    """distinct select on columns"""
    distinct_on: [userCredentialSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecret_order_by!]

    """filter the rows returned"""
    where: userCredentialSecret_bool_exp
  ): [userCredentialSecret!]!

  """
  fetch data from the table: "userCredentialSecretField"
  """
  userCredentialSecretField(
    """distinct select on columns"""
    distinct_on: [userCredentialSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecretField_order_by!]

    """filter the rows returned"""
    where: userCredentialSecretField_bool_exp
  ): [userCredentialSecretField!]!

  """
  fetch data from the table: "userCredentialSecretField" using primary key columns
  """
  userCredentialSecretField_by_pk(id: uuid!): userCredentialSecretField

  """
  fetch aggregated fields from the table: "userCredentialSecret"
  """
  userCredentialSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userCredentialSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecret_order_by!]

    """filter the rows returned"""
    where: userCredentialSecret_bool_exp
  ): userCredentialSecret_aggregate!

  """
  fetch data from the table: "userCredentialSecret" using primary key columns
  """
  userCredentialSecret_by_pk(id: uuid!): userCredentialSecret

  """
  fetch data from the table: "userSecret"
  """
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSecretField"
  """
  userSecretField(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """fetch data from the table: "userSecretField" using primary key columns"""
  userSecretField_by_pk(id: uuid!): userSecretField

  """
  fetch aggregated fields from the table: "userSecret"
  """
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """fetch data from the table: "userSecret" using primary key columns"""
  userSecret_by_pk(id: uuid!): userSecret

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user
  vercelProjects(where: VercelProjectsInput!): VercelProjectsOutput!

  """An array relationship"""
  viewPreferences(
    """distinct select on columns"""
    distinct_on: [viewPreferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [viewPreferences_order_by!]

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!

  """fetch data from the table: "viewPreferences" using primary key columns"""
  viewPreferences_by_pk(id: uuid!): viewPreferences
  viewSecretFields(projectSlug: String!, secretSlug: String!, teamSlug: String!): [DecryptedSecretField!]!
}

enum registrationStep_enum {
  """billing information collection step"""
  billingInformation

  """registration is complete"""
  complete

  """email verification step"""
  emailVerification
}

"""
Boolean expression to compare columns of type "registrationStep_enum". All fields are combined with logical 'AND'.
"""
input registrationStep_enum_comparison_exp {
  _eq: registrationStep_enum
  _in: [registrationStep_enum!]
  _is_null: Boolean
  _neq: registrationStep_enum
  _nin: [registrationStep_enum!]
}

input search_token_by_id_args {
  match: String
}

input search_usage_history_by_id_args {
  match: String
}

input search_user_by_id_args {
  match: String
}

type subscription_root {
  """
  fetch data from the table: "credentialProject"
  """
  credentialProject(
    """distinct select on columns"""
    distinct_on: [credentialProject_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credentialProject_order_by!]

    """filter the rows returned"""
    where: credentialProject_bool_exp
  ): [credentialProject!]!

  """
  fetch data from the table: "credentialProject" using primary key columns
  """
  credentialProject_by_pk(id: uuid!): credentialProject

  """
  fetch data from the table in a streaming manner: "credentialProject"
  """
  credentialProject_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [credentialProject_stream_cursor_input]!

    """filter the rows returned"""
    where: credentialProject_bool_exp
  ): [credentialProject!]!

  """
  fetch data from the table: "credentialToken"
  """
  credentialToken(
    """distinct select on columns"""
    distinct_on: [credentialToken_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credentialToken_order_by!]

    """filter the rows returned"""
    where: credentialToken_bool_exp
  ): [credentialToken!]!

  """fetch data from the table: "credentialToken" using primary key columns"""
  credentialToken_by_pk(id: uuid!): credentialToken

  """
  fetch data from the table in a streaming manner: "credentialToken"
  """
  credentialToken_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [credentialToken_stream_cursor_input]!

    """filter the rows returned"""
    where: credentialToken_bool_exp
  ): [credentialToken!]!
  doesTeamExist(
    """doesTeamExistNative Query Arguments"""
    args: doesTeamExist_arguments!

    """distinct select on columns"""
    distinct_on: [exists_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exists_order_by!]

    """filter the rows returned"""
    where: exists_bool_exp_bool_exp
  ): [exists!]!

  """
  fetch data from the table: "integrationConnect"
  """
  integrationConnect(
    """distinct select on columns"""
    distinct_on: [integrationConnect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationConnect_order_by!]

    """filter the rows returned"""
    where: integrationConnect_bool_exp
  ): [integrationConnect!]!

  """
  fetch aggregated fields from the table: "integrationConnect"
  """
  integrationConnect_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationConnect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationConnect_order_by!]

    """filter the rows returned"""
    where: integrationConnect_bool_exp
  ): integrationConnect_aggregate!

  """
  fetch data from the table: "integrationConnect" using primary key columns
  """
  integrationConnect_by_pk(id: uuid!): integrationConnect

  """
  fetch data from the table in a streaming manner: "integrationConnect"
  """
  integrationConnect_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationConnect_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationConnect_bool_exp
  ): [integrationConnect!]!

  """
  fetch data from the table: "integrationInstallation"
  """
  integrationInstallation(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch data from the table: "integrationInstallationUserSecret" using primary key columns
  """
  integrationInstallationUserSecret_by_pk(id: uuid!): integrationInstallationUserSecret

  """
  fetch data from the table in a streaming manner: "integrationInstallationUserSecret"
  """
  integrationInstallationUserSecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationInstallationUserSecret_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!

  """
  fetch aggregated fields from the table: "integrationInstallation"
  """
  integrationInstallation_aggregate(
    """distinct select on columns"""
    distinct_on: [integrationInstallation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallation_order_by!]

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): integrationInstallation_aggregate!

  """
  fetch data from the table: "integrationInstallation" using primary key columns
  """
  integrationInstallation_by_pk(id: uuid!): integrationInstallation

  """
  fetch data from the table in a streaming manner: "integrationInstallation"
  """
  integrationInstallation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [integrationInstallation_stream_cursor_input]!

    """filter the rows returned"""
    where: integrationInstallation_bool_exp
  ): [integrationInstallation!]!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "notificationUser"
  """
  notificationUser(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """
  fetch data from the table: "notificationUser" using primary key columns
  """
  notificationUser_by_pk(id: uuid!): notificationUser

  """
  fetch data from the table in a streaming manner: "notificationUser"
  """
  notificationUser_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notificationUser_stream_cursor_input]!

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table in a streaming manner: "notification"
  """
  notification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch data from the table: "project"
  """
  project(
    """distinct select on columns"""
    distinct_on: [project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): [project!]!

  """fetch data from the table: "project" using primary key columns"""
  project_by_pk(id: uuid!): project

  """
  fetch data from the table in a streaming manner: "project"
  """
  project_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [project_stream_cursor_input]!

    """filter the rows returned"""
    where: project_bool_exp
  ): [project!]!

  """
  execute function "search_token_by_id" which returns "token"
  """
  search_token_by_id(
    """
    input parameters for function "search_token_by_id"
    """
    args: search_token_by_id_args!

    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  execute function "search_usage_history_by_id" which returns "usageHistory"
  """
  search_usage_history_by_id(
    """
    input parameters for function "search_usage_history_by_id"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  execute function "search_usage_history_by_id" and query aggregates on result of table type "usageHistory"
  """
  search_usage_history_by_id_aggregate(
    """
    input parameters for function "search_usage_history_by_id_aggregate"
    """
    args: search_usage_history_by_id_args!

    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """
  execute function "search_user_by_id" which returns "user"
  """
  search_user_by_id(
    """
    input parameters for function "search_user_by_id"
    """
    args: search_user_by_id_args!

    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "teamInvitation"
  """
  teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """fetch data from the table: "teamInvitation" using primary key columns"""
  teamInvitation_by_pk(id: uuid!): teamInvitation

  """
  fetch data from the table in a streaming manner: "teamInvitation"
  """
  teamInvitation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teamInvitation_stream_cursor_input]!

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """
  fetch data from the table: "teamUser"
  """
  teamUser(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "teamUser"
  """
  teamUser_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """fetch data from the table: "teamUser" using primary key columns"""
  teamUser_by_pk(id: uuid!): teamUser

  """
  fetch data from the table in a streaming manner: "teamUser"
  """
  teamUser_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teamUser_stream_cursor_input]!

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table in a streaming manner: "team"
  """
  team_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [team_stream_cursor_input]!

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """
  fetch data from the table in a streaming manner: "token"
  """
  token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [token_stream_cursor_input]!

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch data from the table: "usageHistory"
  """
  usageHistory(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "usageHistorySecret"
  """
  usageHistorySecret(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """
  fetch aggregated fields from the table: "usageHistorySecret"
  """
  usageHistorySecret_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!

  """
  fetch data from the table: "usageHistorySecret" using primary key columns
  """
  usageHistorySecret_by_pk(id: uuid!): usageHistorySecret

  """
  fetch data from the table in a streaming manner: "usageHistorySecret"
  """
  usageHistorySecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [usageHistorySecret_stream_cursor_input]!

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """
  fetch aggregated fields from the table: "usageHistory"
  """
  usageHistory_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistory_order_by!]

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): usageHistory_aggregate!

  """fetch data from the table: "usageHistory" using primary key columns"""
  usageHistory_by_pk(id: uuid!): usageHistory

  """
  fetch data from the table in a streaming manner: "usageHistory"
  """
  usageHistory_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [usageHistory_stream_cursor_input]!

    """filter the rows returned"""
    where: usageHistory_bool_exp
  ): [usageHistory!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "userCredentialSecret"
  """
  userCredentialSecret(
    """distinct select on columns"""
    distinct_on: [userCredentialSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecret_order_by!]

    """filter the rows returned"""
    where: userCredentialSecret_bool_exp
  ): [userCredentialSecret!]!

  """
  fetch data from the table: "userCredentialSecretField"
  """
  userCredentialSecretField(
    """distinct select on columns"""
    distinct_on: [userCredentialSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecretField_order_by!]

    """filter the rows returned"""
    where: userCredentialSecretField_bool_exp
  ): [userCredentialSecretField!]!

  """
  fetch data from the table: "userCredentialSecretField" using primary key columns
  """
  userCredentialSecretField_by_pk(id: uuid!): userCredentialSecretField

  """
  fetch data from the table in a streaming manner: "userCredentialSecretField"
  """
  userCredentialSecretField_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userCredentialSecretField_stream_cursor_input]!

    """filter the rows returned"""
    where: userCredentialSecretField_bool_exp
  ): [userCredentialSecretField!]!

  """
  fetch aggregated fields from the table: "userCredentialSecret"
  """
  userCredentialSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userCredentialSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecret_order_by!]

    """filter the rows returned"""
    where: userCredentialSecret_bool_exp
  ): userCredentialSecret_aggregate!

  """
  fetch data from the table: "userCredentialSecret" using primary key columns
  """
  userCredentialSecret_by_pk(id: uuid!): userCredentialSecret

  """
  fetch data from the table in a streaming manner: "userCredentialSecret"
  """
  userCredentialSecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userCredentialSecret_stream_cursor_input]!

    """filter the rows returned"""
    where: userCredentialSecret_bool_exp
  ): [userCredentialSecret!]!

  """
  fetch data from the table: "userSecret"
  """
  userSecret(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """
  fetch data from the table: "userSecretField"
  """
  userSecretField(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """fetch data from the table: "userSecretField" using primary key columns"""
  userSecretField_by_pk(id: uuid!): userSecretField

  """
  fetch data from the table in a streaming manner: "userSecretField"
  """
  userSecretField_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSecretField_stream_cursor_input]!

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!

  """
  fetch aggregated fields from the table: "userSecret"
  """
  userSecret_aggregate(
    """distinct select on columns"""
    distinct_on: [userSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecret_order_by!]

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): userSecret_aggregate!

  """fetch data from the table: "userSecret" using primary key columns"""
  userSecret_by_pk(id: uuid!): userSecret

  """
  fetch data from the table in a streaming manner: "userSecret"
  """
  userSecret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [userSecret_stream_cursor_input]!

    """filter the rows returned"""
    where: userSecret_bool_exp
  ): [userSecret!]!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An array relationship"""
  viewPreferences(
    """distinct select on columns"""
    distinct_on: [viewPreferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [viewPreferences_order_by!]

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!

  """fetch data from the table: "viewPreferences" using primary key columns"""
  viewPreferences_by_pk(id: uuid!): viewPreferences

  """
  fetch data from the table in a streaming manner: "viewPreferences"
  """
  viewPreferences_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [viewPreferences_stream_cursor_input]!

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!
}

"""
columns and relationships of "team"
"""
type team {
  createdAt: timestamptz!

  """An array relationship"""
  credentialProjects(
    """distinct select on columns"""
    distinct_on: [credentialProject_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credentialProject_order_by!]

    """filter the rows returned"""
    where: credentialProject_bool_exp
  ): [credentialProject!]!
  description: String!
  id: uuid!

  """An array relationship"""
  invitations(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!
  name: String!

  """An object relationship"""
  owner: user!
  ownerUserId: uuid!

  """An array relationship"""
  projects(
    """distinct select on columns"""
    distinct_on: [project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): [project!]!
  slug: String!
  updatedAt: timestamptz!
}

"""
columns and relationships of "teamInvitation"
"""
type teamInvitation {
  createdAt: timestamptz!
  email: String!
  expiredAt: timestamptz!
  id: uuid!
  invitedBy: uuid!

  """An object relationship"""
  invitedUser: user
  isViewed: Boolean!

  """An object relationship"""
  ownerTeam: user!

  """An object relationship"""
  team: team!
  teamId: uuid!
  teamName: String!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "teamInvitation"
"""
input teamInvitation_aggregate_order_by {
  count: order_by
  max: teamInvitation_max_order_by
  min: teamInvitation_min_order_by
}

"""
Boolean expression to filter rows from the table "teamInvitation". All fields are combined with a logical 'AND'.
"""
input teamInvitation_bool_exp {
  _and: [teamInvitation_bool_exp!]
  _not: teamInvitation_bool_exp
  _or: [teamInvitation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  expiredAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  invitedBy: uuid_comparison_exp
  invitedUser: user_bool_exp
  isViewed: Boolean_comparison_exp
  ownerTeam: user_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  teamName: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "teamInvitation"
"""
enum teamInvitation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  teamInvitation_pkey
}

"""
input type for inserting data into table "teamInvitation"
"""
input teamInvitation_insert_input {
  email: String
  expiredAt: timestamptz
  invitedBy: uuid
  isViewed: Boolean
  teamId: uuid
  teamName: String
}

"""
order by max() on columns of table "teamInvitation"
"""
input teamInvitation_max_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""
order by min() on columns of table "teamInvitation"
"""
input teamInvitation_min_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "teamInvitation"
"""
type teamInvitation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teamInvitation!]!
}

"""
on_conflict condition type for table "teamInvitation"
"""
input teamInvitation_on_conflict {
  constraint: teamInvitation_constraint!
  update_columns: [teamInvitation_update_column!]! = []
  where: teamInvitation_bool_exp
}

"""Ordering options when selecting data from "teamInvitation"."""
input teamInvitation_order_by {
  createdAt: order_by
  email: order_by
  expiredAt: order_by
  id: order_by
  invitedBy: order_by
  invitedUser: user_order_by
  isViewed: order_by
  ownerTeam: user_order_by
  team: team_order_by
  teamId: order_by
  teamName: order_by
  updatedAt: order_by
}

"""primary key columns input for table: teamInvitation"""
input teamInvitation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "teamInvitation"
"""
enum teamInvitation_select_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  expiredAt

  """column name"""
  id

  """column name"""
  invitedBy

  """column name"""
  isViewed

  """column name"""
  teamId

  """column name"""
  teamName

  """column name"""
  updatedAt
}

"""
input type for updating data in table "teamInvitation"
"""
input teamInvitation_set_input {
  isViewed: Boolean
}

"""
Streaming cursor of the table "teamInvitation"
"""
input teamInvitation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teamInvitation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teamInvitation_stream_cursor_value_input {
  createdAt: timestamptz
  email: String
  expiredAt: timestamptz
  id: uuid
  invitedBy: uuid
  isViewed: Boolean
  teamId: uuid
  teamName: String
  updatedAt: timestamptz
}

"""
update columns of table "teamInvitation"
"""
enum teamInvitation_update_column {
  """column name"""
  isViewed
}

input teamInvitation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: teamInvitation_set_input

  """filter the rows which have to be updated"""
  where: teamInvitation_bool_exp!
}

"""
columns and relationships of "teamUser"
"""
type teamUser {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  member: user!

  """An object relationship"""
  team: team!
  teamId: uuid!
  updatedAt: timestamptz!
  userId: uuid!
}

"""
aggregated selection of "teamUser"
"""
type teamUser_aggregate {
  aggregate: teamUser_aggregate_fields
  nodes: [teamUser!]!
}

input teamUser_aggregate_bool_exp {
  count: teamUser_aggregate_bool_exp_count
}

input teamUser_aggregate_bool_exp_count {
  arguments: [teamUser_select_column!]
  distinct: Boolean
  filter: teamUser_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "teamUser"
"""
type teamUser_aggregate_fields {
  count(columns: [teamUser_select_column!], distinct: Boolean): Int!
  max: teamUser_max_fields
  min: teamUser_min_fields
}

"""
order by aggregate values of table "teamUser"
"""
input teamUser_aggregate_order_by {
  count: order_by
  max: teamUser_max_order_by
  min: teamUser_min_order_by
}

"""
Boolean expression to filter rows from the table "teamUser". All fields are combined with a logical 'AND'.
"""
input teamUser_bool_exp {
  _and: [teamUser_bool_exp!]
  _not: teamUser_bool_exp
  _or: [teamUser_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  member: user_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "teamUser"
"""
enum teamUser_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  teamUser_pkey
}

"""
input type for inserting data into table "teamUser"
"""
input teamUser_insert_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type teamUser_max_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "teamUser"
"""
input teamUser_max_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type teamUser_min_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "teamUser"
"""
input teamUser_min_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "teamUser"
"""
type teamUser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teamUser!]!
}

"""
on_conflict condition type for table "teamUser"
"""
input teamUser_on_conflict {
  constraint: teamUser_constraint!
  update_columns: [teamUser_update_column!]! = []
  where: teamUser_bool_exp
}

"""Ordering options when selecting data from "teamUser"."""
input teamUser_order_by {
  createdAt: order_by
  id: order_by
  member: user_order_by
  team: team_order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""primary key columns input for table: teamUser"""
input teamUser_pk_columns_input {
  id: uuid!
}

"""
select columns of table "teamUser"
"""
enum teamUser_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "teamUser"
"""
input teamUser_set_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "teamUser"
"""
input teamUser_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teamUser_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teamUser_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "teamUser"
"""
enum teamUser_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

input teamUser_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: teamUser_set_input

  """filter the rows which have to be updated"""
  where: teamUser_bool_exp!
}

"""
aggregated selection of "team"
"""
type team_aggregate {
  aggregate: team_aggregate_fields
  nodes: [team!]!
}

input team_aggregate_bool_exp {
  count: team_aggregate_bool_exp_count
}

input team_aggregate_bool_exp_count {
  arguments: [team_select_column!]
  distinct: Boolean
  filter: team_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "team"
"""
type team_aggregate_fields {
  count(columns: [team_select_column!], distinct: Boolean): Int!
  max: team_max_fields
  min: team_min_fields
}

"""
order by aggregate values of table "team"
"""
input team_aggregate_order_by {
  count: order_by
  max: team_max_order_by
  min: team_min_order_by
}

"""
Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
"""
input team_bool_exp {
  _and: [team_bool_exp!]
  _not: team_bool_exp
  _or: [team_bool_exp!]
  createdAt: timestamptz_comparison_exp
  credentialProjects: credentialProject_bool_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  invitations: teamInvitation_bool_exp
  members: teamUser_bool_exp
  members_aggregate: teamUser_aggregate_bool_exp
  name: String_comparison_exp
  owner: user_bool_exp
  ownerUserId: uuid_comparison_exp
  projects: project_bool_exp
  slug: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type team_max_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  ownerUserId: uuid
  slug: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "team"
"""
input team_max_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  name: order_by
  ownerUserId: order_by
  slug: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type team_min_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  ownerUserId: uuid
  slug: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "team"
"""
input team_min_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  name: order_by
  ownerUserId: order_by
  slug: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "team"
"""
type team_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [team!]!
}

"""Ordering options when selecting data from "team"."""
input team_order_by {
  createdAt: order_by
  credentialProjects_aggregate: credentialProject_aggregate_order_by
  description: order_by
  id: order_by
  invitations_aggregate: teamInvitation_aggregate_order_by
  members_aggregate: teamUser_aggregate_order_by
  name: order_by
  owner: user_order_by
  ownerUserId: order_by
  projects_aggregate: project_aggregate_order_by
  slug: order_by
  updatedAt: order_by
}

"""primary key columns input for table: team"""
input team_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team"
"""
enum team_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  ownerUserId

  """column name"""
  slug

  """column name"""
  updatedAt
}

"""
input type for updating data in table "team"
"""
input team_set_input {
  description: String
  name: String
  slug: String
}

"""
Streaming cursor of the table "team"
"""
input team_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: team_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input team_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  ownerUserId: uuid
  slug: String
  updatedAt: timestamptz
}

input team_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: team_set_input

  """filter the rows which have to be updated"""
  where: team_bool_exp!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Table for storing user project tokens."""
type token {
  created_at: timestamptz!
  expiresAt: timestamptz
  id: uuid!
  name: String!

  """An object relationship"""
  project: project!
  projectId: uuid!
  updated_at: timestamptz!
}

"""
order by aggregate values of table "token"
"""
input token_aggregate_order_by {
  count: order_by
  max: token_max_order_by
  min: token_min_order_by
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  created_at: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  project: project_bool_exp
  projectId: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
order by max() on columns of table "token"
"""
input token_max_order_by {
  created_at: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  projectId: order_by
  updated_at: order_by
}

"""
order by min() on columns of table "token"
"""
input token_min_order_by {
  created_at: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  projectId: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "token"
"""
type token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token!]!
}

"""Ordering options when selecting data from "token"."""
input token_order_by {
  created_at: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  project: project_order_by
  projectId: order_by
  updated_at: order_by
}

"""primary key columns input for table: token"""
input token_pk_columns_input {
  id: uuid!
}

"""
select columns of table "token"
"""
enum token_select_column {
  """column name"""
  created_at

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  projectId

  """column name"""
  updated_at
}

"""
input type for updating data in table "token"
"""
input token_set_input {
  name: String
}

"""
Streaming cursor of the table "token"
"""
input token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input token_stream_cursor_value_input {
  created_at: timestamptz
  expiresAt: timestamptz
  id: uuid
  name: String
  projectId: uuid
  updated_at: timestamptz
}

input token_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: token_set_input

  """filter the rows which have to be updated"""
  where: token_bool_exp!
}

"""
columns and relationships of "usageHistory"
"""
type usageHistory {
  callerName: String
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  project: project!
  projectId: uuid!
  remoteIp: String!

  """An array relationship"""
  secrets(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  secrets_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!
  updatedAt: timestamptz!
}

"""
columns and relationships of "usageHistorySecret"
"""
type usageHistorySecret {
  createdAt: timestamptz!
  id: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  usageHistory: usageHistory!
  usageHistoryId: uuid!

  """An object relationship"""
  userSecret: userSecret
  userSecretId: uuid
}

"""
aggregated selection of "usageHistorySecret"
"""
type usageHistorySecret_aggregate {
  aggregate: usageHistorySecret_aggregate_fields
  nodes: [usageHistorySecret!]!
}

input usageHistorySecret_aggregate_bool_exp {
  count: usageHistorySecret_aggregate_bool_exp_count
}

input usageHistorySecret_aggregate_bool_exp_count {
  arguments: [usageHistorySecret_select_column!]
  distinct: Boolean
  filter: usageHistorySecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "usageHistorySecret"
"""
type usageHistorySecret_aggregate_fields {
  count(columns: [usageHistorySecret_select_column!], distinct: Boolean): Int!
  max: usageHistorySecret_max_fields
  min: usageHistorySecret_min_fields
}

"""
order by aggregate values of table "usageHistorySecret"
"""
input usageHistorySecret_aggregate_order_by {
  count: order_by
  max: usageHistorySecret_max_order_by
  min: usageHistorySecret_min_order_by
}

"""
Boolean expression to filter rows from the table "usageHistorySecret". All fields are combined with a logical 'AND'.
"""
input usageHistorySecret_bool_exp {
  _and: [usageHistorySecret_bool_exp!]
  _not: usageHistorySecret_bool_exp
  _or: [usageHistorySecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  usageHistory: usageHistory_bool_exp
  usageHistoryId: uuid_comparison_exp
  userSecret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
}

"""aggregate max on columns"""
type usageHistorySecret_max_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
order by max() on columns of table "usageHistorySecret"
"""
input usageHistorySecret_max_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistoryId: order_by
  userSecretId: order_by
}

"""aggregate min on columns"""
type usageHistorySecret_min_fields {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
order by min() on columns of table "usageHistorySecret"
"""
input usageHistorySecret_min_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistoryId: order_by
  userSecretId: order_by
}

"""Ordering options when selecting data from "usageHistorySecret"."""
input usageHistorySecret_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  usageHistory: usageHistory_order_by
  usageHistoryId: order_by
  userSecret: userSecret_order_by
  userSecretId: order_by
}

"""
select columns of table "usageHistorySecret"
"""
enum usageHistorySecret_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  usageHistoryId

  """column name"""
  userSecretId
}

"""
Streaming cursor of the table "usageHistorySecret"
"""
input usageHistorySecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: usageHistorySecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input usageHistorySecret_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  updatedAt: timestamptz
  usageHistoryId: uuid
  userSecretId: uuid
}

"""
aggregated selection of "usageHistory"
"""
type usageHistory_aggregate {
  aggregate: usageHistory_aggregate_fields
  nodes: [usageHistory!]!
}

input usageHistory_aggregate_bool_exp {
  count: usageHistory_aggregate_bool_exp_count
}

input usageHistory_aggregate_bool_exp_count {
  arguments: [usageHistory_select_column!]
  distinct: Boolean
  filter: usageHistory_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "usageHistory"
"""
type usageHistory_aggregate_fields {
  count(columns: [usageHistory_select_column!], distinct: Boolean): Int!
  max: usageHistory_max_fields
  min: usageHistory_min_fields
}

"""
order by aggregate values of table "usageHistory"
"""
input usageHistory_aggregate_order_by {
  count: order_by
  max: usageHistory_max_order_by
  min: usageHistory_min_order_by
}

"""
Boolean expression to filter rows from the table "usageHistory". All fields are combined with a logical 'AND'.
"""
input usageHistory_bool_exp {
  _and: [usageHistory_bool_exp!]
  _not: usageHistory_bool_exp
  _or: [usageHistory_bool_exp!]
  callerName: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  project: project_bool_exp
  projectId: uuid_comparison_exp
  remoteIp: String_comparison_exp
  secrets: usageHistorySecret_bool_exp
  secrets_aggregate: usageHistorySecret_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type usageHistory_max_fields {
  callerName: String
  createdAt: timestamptz
  id: uuid
  projectId: uuid
  remoteIp: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "usageHistory"
"""
input usageHistory_max_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  projectId: order_by
  remoteIp: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type usageHistory_min_fields {
  callerName: String
  createdAt: timestamptz
  id: uuid
  projectId: uuid
  remoteIp: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "usageHistory"
"""
input usageHistory_min_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  projectId: order_by
  remoteIp: order_by
  updatedAt: order_by
}

"""Ordering options when selecting data from "usageHistory"."""
input usageHistory_order_by {
  callerName: order_by
  createdAt: order_by
  id: order_by
  project: project_order_by
  projectId: order_by
  remoteIp: order_by
  secrets_aggregate: usageHistorySecret_aggregate_order_by
  updatedAt: order_by
}

"""
select columns of table "usageHistory"
"""
enum usageHistory_select_column {
  """column name"""
  callerName

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  projectId

  """column name"""
  remoteIp

  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "usageHistory"
"""
input usageHistory_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: usageHistory_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input usageHistory_stream_cursor_value_input {
  callerName: String
  createdAt: timestamptz
  id: uuid
  projectId: uuid
  remoteIp: String
  updatedAt: timestamptz
}

"""
columns and relationships of "user"
"""
type user {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz!
  email: String!

  """A computed field which return the hasPassword boolean value"""
  hasPassword: Boolean
  id: uuid!

  """An array relationship"""
  invitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!
  name: String!

  """An array relationship"""
  notificationUsers(
    """distinct select on columns"""
    distinct_on: [notificationUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notificationUser_order_by!]

    """filter the rows returned"""
    where: notificationUser_bool_exp
  ): [notificationUser!]!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """An array relationship"""
  ownedTeams(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """An aggregate relationship"""
  ownedTeams_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!
  registrationStep: registrationStep_enum

  """An array relationship"""
  teams(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!
  updatedAt: timestamptz!

  """An object relationship"""
  user_activeTeam: team

  """An array relationship"""
  user_teamInvitation(
    """distinct select on columns"""
    distinct_on: [teamInvitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamInvitation_order_by!]

    """filter the rows returned"""
    where: teamInvitation_bool_exp
  ): [teamInvitation!]!

  """An array relationship"""
  viewPreferences(
    """distinct select on columns"""
    distinct_on: [viewPreferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [viewPreferences_order_by!]

    """filter the rows returned"""
    where: viewPreferences_bool_exp
  ): [viewPreferences!]!
}

"""Custom secrets with OAuth credentials."""
type userCredentialSecret {
  createdAt: timestamptz!
  description: String!
  expiresAt: timestamptz!

  """An array relationship"""
  fields(
    """distinct select on columns"""
    distinct_on: [userCredentialSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userCredentialSecretField_order_by!]

    """filter the rows returned"""
    where: userCredentialSecretField_bool_exp
  ): [userCredentialSecretField!]!
  id: uuid!
  meta(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!

  """An object relationship"""
  project: credentialProject!
  projectId: uuid!
  slug: String!
  updatedAt: timestamptz!
  vendor: credentialVendorEnum_enum!
}

"""userCredentialSecret fields"""
type userCredentialSecretField {
  createdAt: timestamptz!
  id: uuid!
  name: String!
  slug: String!
  updatedAt: timestamptz!

  """An object relationship"""
  userCredentialSecret: userCredentialSecret!
  userCredentialSecretId: uuid!
  value: String!
}

"""
order by aggregate values of table "userCredentialSecretField"
"""
input userCredentialSecretField_aggregate_order_by {
  count: order_by
  max: userCredentialSecretField_max_order_by
  min: userCredentialSecretField_min_order_by
}

"""
input type for inserting array relation for remote table "userCredentialSecretField"
"""
input userCredentialSecretField_arr_rel_insert_input {
  data: [userCredentialSecretField_insert_input!]!

  """upsert condition"""
  on_conflict: userCredentialSecretField_on_conflict
}

"""
Boolean expression to filter rows from the table "userCredentialSecretField". All fields are combined with a logical 'AND'.
"""
input userCredentialSecretField_bool_exp {
  _and: [userCredentialSecretField_bool_exp!]
  _not: userCredentialSecretField_bool_exp
  _or: [userCredentialSecretField_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userCredentialSecret: userCredentialSecret_bool_exp
  userCredentialSecretId: uuid_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "userCredentialSecretField"
"""
enum userCredentialSecretField_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userCredentialSecretField_id_key

  """
  unique or primary key constraint on columns "id"
  """
  userCredentialSecretField_pkey
}

"""
input type for inserting data into table "userCredentialSecretField"
"""
input userCredentialSecretField_insert_input {
  name: String
  slug: String
  userCredentialSecret: userCredentialSecret_obj_rel_insert_input
  userCredentialSecretId: uuid
  value: String
}

"""
order by max() on columns of table "userCredentialSecretField"
"""
input userCredentialSecretField_max_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userCredentialSecretId: order_by
  value: order_by
}

"""
order by min() on columns of table "userCredentialSecretField"
"""
input userCredentialSecretField_min_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userCredentialSecretId: order_by
  value: order_by
}

"""
response of any mutation on the table "userCredentialSecretField"
"""
type userCredentialSecretField_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userCredentialSecretField!]!
}

"""
on_conflict condition type for table "userCredentialSecretField"
"""
input userCredentialSecretField_on_conflict {
  constraint: userCredentialSecretField_constraint!
  update_columns: [userCredentialSecretField_update_column!]! = []
  where: userCredentialSecretField_bool_exp
}

"""Ordering options when selecting data from "userCredentialSecretField"."""
input userCredentialSecretField_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  updatedAt: order_by
  userCredentialSecret: userCredentialSecret_order_by
  userCredentialSecretId: order_by
  value: order_by
}

"""primary key columns input for table: userCredentialSecretField"""
input userCredentialSecretField_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userCredentialSecretField"
"""
enum userCredentialSecretField_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  updatedAt

  """column name"""
  userCredentialSecretId

  """column name"""
  value
}

"""
input type for updating data in table "userCredentialSecretField"
"""
input userCredentialSecretField_set_input {
  name: String
  slug: String
  value: String
}

"""
Streaming cursor of the table "userCredentialSecretField"
"""
input userCredentialSecretField_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userCredentialSecretField_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userCredentialSecretField_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  updatedAt: timestamptz
  userCredentialSecretId: uuid
  value: String
}

"""
update columns of table "userCredentialSecretField"
"""
enum userCredentialSecretField_update_column {
  """column name"""
  name

  """column name"""
  slug

  """column name"""
  value
}

input userCredentialSecretField_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userCredentialSecretField_set_input

  """filter the rows which have to be updated"""
  where: userCredentialSecretField_bool_exp!
}

"""
aggregated selection of "userCredentialSecret"
"""
type userCredentialSecret_aggregate {
  aggregate: userCredentialSecret_aggregate_fields
  nodes: [userCredentialSecret!]!
}

input userCredentialSecret_aggregate_bool_exp {
  count: userCredentialSecret_aggregate_bool_exp_count
}

input userCredentialSecret_aggregate_bool_exp_count {
  arguments: [userCredentialSecret_select_column!]
  distinct: Boolean
  filter: userCredentialSecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "userCredentialSecret"
"""
type userCredentialSecret_aggregate_fields {
  count(columns: [userCredentialSecret_select_column!], distinct: Boolean): Int!
  max: userCredentialSecret_max_fields
  min: userCredentialSecret_min_fields
}

"""
order by aggregate values of table "userCredentialSecret"
"""
input userCredentialSecret_aggregate_order_by {
  count: order_by
  max: userCredentialSecret_max_order_by
  min: userCredentialSecret_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input userCredentialSecret_append_input {
  meta: jsonb
}

"""
Boolean expression to filter rows from the table "userCredentialSecret". All fields are combined with a logical 'AND'.
"""
input userCredentialSecret_bool_exp {
  _and: [userCredentialSecret_bool_exp!]
  _not: userCredentialSecret_bool_exp
  _or: [userCredentialSecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  expiresAt: timestamptz_comparison_exp
  fields: userCredentialSecretField_bool_exp
  id: uuid_comparison_exp
  meta: jsonb_comparison_exp
  name: String_comparison_exp
  project: credentialProject_bool_exp
  projectId: uuid_comparison_exp
  slug: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  vendor: credentialVendorEnum_enum_comparison_exp
}

"""
unique or primary key constraints on table "userCredentialSecret"
"""
enum userCredentialSecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userCredentialSecret_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input userCredentialSecret_delete_at_path_input {
  meta: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input userCredentialSecret_delete_elem_input {
  meta: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input userCredentialSecret_delete_key_input {
  meta: String
}

"""
input type for inserting data into table "userCredentialSecret"
"""
input userCredentialSecret_insert_input {
  description: String
  expiresAt: timestamptz
  fields: userCredentialSecretField_arr_rel_insert_input
  meta: jsonb
  name: String
  projectId: uuid
  slug: String
  vendor: credentialVendorEnum_enum
}

"""aggregate max on columns"""
type userCredentialSecret_max_fields {
  createdAt: timestamptz
  description: String
  expiresAt: timestamptz
  id: uuid
  name: String
  projectId: uuid
  slug: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "userCredentialSecret"
"""
input userCredentialSecret_max_order_by {
  createdAt: order_by
  description: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  projectId: order_by
  slug: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type userCredentialSecret_min_fields {
  createdAt: timestamptz
  description: String
  expiresAt: timestamptz
  id: uuid
  name: String
  projectId: uuid
  slug: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "userCredentialSecret"
"""
input userCredentialSecret_min_order_by {
  createdAt: order_by
  description: order_by
  expiresAt: order_by
  id: order_by
  name: order_by
  projectId: order_by
  slug: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "userCredentialSecret"
"""
type userCredentialSecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userCredentialSecret!]!
}

"""
input type for inserting object relation for remote table "userCredentialSecret"
"""
input userCredentialSecret_obj_rel_insert_input {
  data: userCredentialSecret_insert_input!

  """upsert condition"""
  on_conflict: userCredentialSecret_on_conflict
}

"""
on_conflict condition type for table "userCredentialSecret"
"""
input userCredentialSecret_on_conflict {
  constraint: userCredentialSecret_constraint!
  update_columns: [userCredentialSecret_update_column!]! = []
  where: userCredentialSecret_bool_exp
}

"""Ordering options when selecting data from "userCredentialSecret"."""
input userCredentialSecret_order_by {
  createdAt: order_by
  description: order_by
  expiresAt: order_by
  fields_aggregate: userCredentialSecretField_aggregate_order_by
  id: order_by
  meta: order_by
  name: order_by
  project: credentialProject_order_by
  projectId: order_by
  slug: order_by
  updatedAt: order_by
  vendor: order_by
}

"""primary key columns input for table: userCredentialSecret"""
input userCredentialSecret_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input userCredentialSecret_prepend_input {
  meta: jsonb
}

"""
select columns of table "userCredentialSecret"
"""
enum userCredentialSecret_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  projectId

  """column name"""
  slug

  """column name"""
  updatedAt

  """column name"""
  vendor
}

"""
input type for updating data in table "userCredentialSecret"
"""
input userCredentialSecret_set_input {
  description: String
  expiresAt: timestamptz
  meta: jsonb
  name: String
  slug: String
  vendor: credentialVendorEnum_enum
}

"""
Streaming cursor of the table "userCredentialSecret"
"""
input userCredentialSecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userCredentialSecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userCredentialSecret_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  expiresAt: timestamptz
  id: uuid
  meta: jsonb
  name: String
  projectId: uuid
  slug: String
  updatedAt: timestamptz
  vendor: credentialVendorEnum_enum
}

"""
update columns of table "userCredentialSecret"
"""
enum userCredentialSecret_update_column {
  """column name"""
  description

  """column name"""
  expiresAt

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  vendor
}

input userCredentialSecret_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: userCredentialSecret_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: userCredentialSecret_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: userCredentialSecret_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: userCredentialSecret_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: userCredentialSecret_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: userCredentialSecret_set_input

  """filter the rows which have to be updated"""
  where: userCredentialSecret_bool_exp!
}

"""Table of user secrets."""
type userSecret {
  createdAt: timestamptz!
  description: String!

  """An array relationship"""
  fields(
    """distinct select on columns"""
    distinct_on: [userSecretField_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userSecretField_order_by!]

    """filter the rows returned"""
    where: userSecretField_bool_exp
  ): [userSecretField!]!
  id: uuid!

  """An array relationship"""
  installations(
    """distinct select on columns"""
    distinct_on: [integrationInstallationUserSecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationInstallationUserSecret_order_by!]

    """filter the rows returned"""
    where: integrationInstallationUserSecret_bool_exp
  ): [integrationInstallationUserSecret!]!
  meta(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!

  """An object relationship"""
  project: project!
  projectId: uuid!
  slug: String!
  updatedAt: timestamptz!

  """An array relationship"""
  userSecret_usageHistorySecrets(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): [usageHistorySecret!]!

  """An aggregate relationship"""
  userSecret_usageHistorySecrets_aggregate(
    """distinct select on columns"""
    distinct_on: [usageHistorySecret_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [usageHistorySecret_order_by!]

    """filter the rows returned"""
    where: usageHistorySecret_bool_exp
  ): usageHistorySecret_aggregate!
  vendor: vendorEnum_enum!
}

"""Fields of the user secrets."""
type userSecretField {
  createdAt: timestamptz!
  id: uuid!
  name: String!
  slug: String!
  sortId: Int!
  updatedAt: timestamptz!

  """An object relationship"""
  userSecret: userSecret!
  userSecretId: uuid!
  value: String!
}

"""
order by aggregate values of table "userSecretField"
"""
input userSecretField_aggregate_order_by {
  avg: userSecretField_avg_order_by
  count: order_by
  max: userSecretField_max_order_by
  min: userSecretField_min_order_by
  stddev: userSecretField_stddev_order_by
  stddev_pop: userSecretField_stddev_pop_order_by
  stddev_samp: userSecretField_stddev_samp_order_by
  sum: userSecretField_sum_order_by
  var_pop: userSecretField_var_pop_order_by
  var_samp: userSecretField_var_samp_order_by
  variance: userSecretField_variance_order_by
}

"""
input type for inserting array relation for remote table "userSecretField"
"""
input userSecretField_arr_rel_insert_input {
  data: [userSecretField_insert_input!]!

  """upsert condition"""
  on_conflict: userSecretField_on_conflict
}

"""
order by avg() on columns of table "userSecretField"
"""
input userSecretField_avg_order_by {
  sortId: order_by
}

"""
Boolean expression to filter rows from the table "userSecretField". All fields are combined with a logical 'AND'.
"""
input userSecretField_bool_exp {
  _and: [userSecretField_bool_exp!]
  _not: userSecretField_bool_exp
  _or: [userSecretField_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  sortId: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSecret: userSecret_bool_exp
  userSecretId: uuid_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "userSecretField"
"""
enum userSecretField_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userSecretField_pkey
}

"""
input type for inserting data into table "userSecretField"
"""
input userSecretField_insert_input {
  name: String
  slug: String
  userSecret: userSecret_obj_rel_insert_input
  userSecretId: uuid
  value: String
}

"""
order by max() on columns of table "userSecretField"
"""
input userSecretField_max_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  sortId: order_by
  updatedAt: order_by
  userSecretId: order_by
  value: order_by
}

"""
order by min() on columns of table "userSecretField"
"""
input userSecretField_min_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  sortId: order_by
  updatedAt: order_by
  userSecretId: order_by
  value: order_by
}

"""
response of any mutation on the table "userSecretField"
"""
type userSecretField_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSecretField!]!
}

"""
on_conflict condition type for table "userSecretField"
"""
input userSecretField_on_conflict {
  constraint: userSecretField_constraint!
  update_columns: [userSecretField_update_column!]! = []
  where: userSecretField_bool_exp
}

"""Ordering options when selecting data from "userSecretField"."""
input userSecretField_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  slug: order_by
  sortId: order_by
  updatedAt: order_by
  userSecret: userSecret_order_by
  userSecretId: order_by
  value: order_by
}

"""primary key columns input for table: userSecretField"""
input userSecretField_pk_columns_input {
  id: uuid!
}

"""
select columns of table "userSecretField"
"""
enum userSecretField_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  sortId

  """column name"""
  updatedAt

  """column name"""
  userSecretId

  """column name"""
  value
}

"""
input type for updating data in table "userSecretField"
"""
input userSecretField_set_input {
  name: String
  slug: String
  userSecretId: uuid
  value: String
}

"""
order by stddev() on columns of table "userSecretField"
"""
input userSecretField_stddev_order_by {
  sortId: order_by
}

"""
order by stddev_pop() on columns of table "userSecretField"
"""
input userSecretField_stddev_pop_order_by {
  sortId: order_by
}

"""
order by stddev_samp() on columns of table "userSecretField"
"""
input userSecretField_stddev_samp_order_by {
  sortId: order_by
}

"""
Streaming cursor of the table "userSecretField"
"""
input userSecretField_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSecretField_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSecretField_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  name: String
  slug: String
  sortId: Int
  updatedAt: timestamptz
  userSecretId: uuid
  value: String
}

"""
order by sum() on columns of table "userSecretField"
"""
input userSecretField_sum_order_by {
  sortId: order_by
}

"""
update columns of table "userSecretField"
"""
enum userSecretField_update_column {
  """column name"""
  name

  """column name"""
  slug

  """column name"""
  userSecretId

  """column name"""
  value
}

input userSecretField_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: userSecretField_set_input

  """filter the rows which have to be updated"""
  where: userSecretField_bool_exp!
}

"""
order by var_pop() on columns of table "userSecretField"
"""
input userSecretField_var_pop_order_by {
  sortId: order_by
}

"""
order by var_samp() on columns of table "userSecretField"
"""
input userSecretField_var_samp_order_by {
  sortId: order_by
}

"""
order by variance() on columns of table "userSecretField"
"""
input userSecretField_variance_order_by {
  sortId: order_by
}

"""
aggregated selection of "userSecret"
"""
type userSecret_aggregate {
  aggregate: userSecret_aggregate_fields
  nodes: [userSecret!]!
}

input userSecret_aggregate_bool_exp {
  count: userSecret_aggregate_bool_exp_count
}

input userSecret_aggregate_bool_exp_count {
  arguments: [userSecret_select_column!]
  distinct: Boolean
  filter: userSecret_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "userSecret"
"""
type userSecret_aggregate_fields {
  count(columns: [userSecret_select_column!], distinct: Boolean): Int!
  max: userSecret_max_fields
  min: userSecret_min_fields
}

"""
order by aggregate values of table "userSecret"
"""
input userSecret_aggregate_order_by {
  count: order_by
  max: userSecret_max_order_by
  min: userSecret_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input userSecret_append_input {
  meta: jsonb
}

"""
Boolean expression to filter rows from the table "userSecret". All fields are combined with a logical 'AND'.
"""
input userSecret_bool_exp {
  _and: [userSecret_bool_exp!]
  _not: userSecret_bool_exp
  _or: [userSecret_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  fields: userSecretField_bool_exp
  id: uuid_comparison_exp
  installations: integrationInstallationUserSecret_bool_exp
  meta: jsonb_comparison_exp
  name: String_comparison_exp
  project: project_bool_exp
  projectId: uuid_comparison_exp
  slug: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSecret_usageHistorySecrets: usageHistorySecret_bool_exp
  userSecret_usageHistorySecrets_aggregate: usageHistorySecret_aggregate_bool_exp
  vendor: vendorEnum_enum_comparison_exp
}

"""
unique or primary key constraints on table "userSecret"
"""
enum userSecret_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  userSecret_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input userSecret_delete_at_path_input {
  meta: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input userSecret_delete_elem_input {
  meta: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input userSecret_delete_key_input {
  meta: String
}

"""
input type for inserting data into table "userSecret"
"""
input userSecret_insert_input {
  description: String
  fields: userSecretField_arr_rel_insert_input
  installations: integrationInstallationUserSecret_arr_rel_insert_input
  meta: jsonb
  name: String
  projectId: uuid
  slug: String
  vendor: vendorEnum_enum
}

"""aggregate max on columns"""
type userSecret_max_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  projectId: uuid
  slug: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "userSecret"
"""
input userSecret_max_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  name: order_by
  projectId: order_by
  slug: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type userSecret_min_fields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  projectId: uuid
  slug: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "userSecret"
"""
input userSecret_min_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  name: order_by
  projectId: order_by
  slug: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "userSecret"
"""
type userSecret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userSecret!]!
}

"""
input type for inserting object relation for remote table "userSecret"
"""
input userSecret_obj_rel_insert_input {
  data: userSecret_insert_input!

  """upsert condition"""
  on_conflict: userSecret_on_conflict
}

"""
on_conflict condition type for table "userSecret"
"""
input userSecret_on_conflict {
  constraint: userSecret_constraint!
  update_columns: [userSecret_update_column!]! = []
  where: userSecret_bool_exp
}

"""Ordering options when selecting data from "userSecret"."""
input userSecret_order_by {
  createdAt: order_by
  description: order_by
  fields_aggregate: userSecretField_aggregate_order_by
  id: order_by
  installations_aggregate: integrationInstallationUserSecret_aggregate_order_by
  meta: order_by
  name: order_by
  project: project_order_by
  projectId: order_by
  slug: order_by
  updatedAt: order_by
  userSecret_usageHistorySecrets_aggregate: usageHistorySecret_aggregate_order_by
  vendor: order_by
}

"""primary key columns input for table: userSecret"""
input userSecret_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input userSecret_prepend_input {
  meta: jsonb
}

"""
select columns of table "userSecret"
"""
enum userSecret_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  projectId

  """column name"""
  slug

  """column name"""
  updatedAt

  """column name"""
  vendor
}

"""
input type for updating data in table "userSecret"
"""
input userSecret_set_input {
  description: String
  meta: jsonb
  name: String
  slug: String
  vendor: vendorEnum_enum
}

"""
Streaming cursor of the table "userSecret"
"""
input userSecret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: userSecret_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input userSecret_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  id: uuid
  meta: jsonb
  name: String
  projectId: uuid
  slug: String
  updatedAt: timestamptz
  vendor: vendorEnum_enum
}

"""
update columns of table "userSecret"
"""
enum userSecret_update_column {
  """column name"""
  description

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  vendor
}

input userSecret_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: userSecret_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: userSecret_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: userSecret_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: userSecret_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: userSecret_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: userSecret_set_input

  """filter the rows which have to be updated"""
  where: userSecret_bool_exp!
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  activeTeamId: uuid_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  hasPassword: Boolean_comparison_exp
  id: uuid_comparison_exp
  invitation: teamInvitation_bool_exp
  name: String_comparison_exp
  notificationUsers: notificationUser_bool_exp
  notifications: notification_bool_exp
  ownedTeams: team_bool_exp
  ownedTeams_aggregate: team_aggregate_bool_exp
  registrationStep: registrationStep_enum_comparison_exp
  teams: teamUser_bool_exp
  teams_aggregate: teamUser_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  user_activeTeam: team_bool_exp
  user_teamInvitation: teamInvitation_bool_exp
  viewPreferences: viewPreferences_bool_exp
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  activeTeamId: order_by
  avatarUrl: order_by
  createdAt: order_by
  email: order_by
  hasPassword: order_by
  id: order_by
  invitation_aggregate: teamInvitation_aggregate_order_by
  name: order_by
  notificationUsers_aggregate: notificationUser_aggregate_order_by
  notifications_aggregate: notification_aggregate_order_by
  ownedTeams_aggregate: team_aggregate_order_by
  registrationStep: order_by
  teams_aggregate: teamUser_aggregate_order_by
  updatedAt: order_by
  user_activeTeam: team_order_by
  user_teamInvitation_aggregate: teamInvitation_aggregate_order_by
  viewPreferences_aggregate: viewPreferences_aggregate_order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  activeTeamId

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  registrationStep

  """column name"""
  updatedAt
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  activeTeamId: uuid
  avatarUrl: String
  name: String
  registrationStep: registrationStep_enum
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  activeTeamId: uuid
  avatarUrl: String
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  registrationStep: registrationStep_enum
  updatedAt: timestamptz
}

input user_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

enum vendorEnum_enum {
  agora
  ansible
  auth0
  aws
  azure
  bitbucket
  braintree
  cloudflare
  datadog
  digitalOcean
  discord
  docker
  dropbox
  facebook
  figma
  gemini
  gitHub
  gitLab
  google
  googleCloud
  jenkins
  jira
  kubernetes
  linear
  linkedIn
  mailchimp
  mixpanel
  netlify
  openAI
  other
  paypal
  pulumi
  reddit
  salesforce
  segment
  sendgrid
  shopify
  slack
  stripe
  terraform
  trello
  twilio
  twitter
  vercel
  zoom
}

"""
Boolean expression to compare columns of type "vendorEnum_enum". All fields are combined with logical 'AND'.
"""
input vendorEnum_enum_comparison_exp {
  _eq: vendorEnum_enum
  _in: [vendorEnum_enum!]
  _is_null: Boolean
  _neq: vendorEnum_enum
  _nin: [vendorEnum_enum!]
}

"""
columns and relationships of "viewPreferences"
"""
type viewPreferences {
  id: uuid!
  isSortingReversed: Boolean!
  layout: String
  listId: listIdEnum_enum!
  sortedBy: String
}

"""
order by aggregate values of table "viewPreferences"
"""
input viewPreferences_aggregate_order_by {
  count: order_by
  max: viewPreferences_max_order_by
  min: viewPreferences_min_order_by
}

"""
Boolean expression to filter rows from the table "viewPreferences". All fields are combined with a logical 'AND'.
"""
input viewPreferences_bool_exp {
  _and: [viewPreferences_bool_exp!]
  _not: viewPreferences_bool_exp
  _or: [viewPreferences_bool_exp!]
  id: uuid_comparison_exp
  isSortingReversed: Boolean_comparison_exp
  layout: String_comparison_exp
  listId: listIdEnum_enum_comparison_exp
  sortedBy: String_comparison_exp
}

"""
unique or primary key constraints on table "viewPreferences"
"""
enum viewPreferences_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  viewPreferences_pkey

  """
  unique or primary key constraint on columns "userId", "listId"
  """
  viewPreferences_userId_listId_key
}

"""
input type for inserting data into table "viewPreferences"
"""
input viewPreferences_insert_input {
  isSortingReversed: Boolean
  layout: String
  listId: listIdEnum_enum
  sortedBy: String
  userId: uuid
}

"""
order by max() on columns of table "viewPreferences"
"""
input viewPreferences_max_order_by {
  id: order_by
  layout: order_by
  sortedBy: order_by
}

"""
order by min() on columns of table "viewPreferences"
"""
input viewPreferences_min_order_by {
  id: order_by
  layout: order_by
  sortedBy: order_by
}

"""
response of any mutation on the table "viewPreferences"
"""
type viewPreferences_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [viewPreferences!]!
}

"""
on_conflict condition type for table "viewPreferences"
"""
input viewPreferences_on_conflict {
  constraint: viewPreferences_constraint!
  update_columns: [viewPreferences_update_column!]! = []
  where: viewPreferences_bool_exp
}

"""Ordering options when selecting data from "viewPreferences"."""
input viewPreferences_order_by {
  id: order_by
  isSortingReversed: order_by
  layout: order_by
  listId: order_by
  sortedBy: order_by
}

"""primary key columns input for table: viewPreferences"""
input viewPreferences_pk_columns_input {
  id: uuid!
}

"""
select columns of table "viewPreferences"
"""
enum viewPreferences_select_column {
  """column name"""
  id

  """column name"""
  isSortingReversed

  """column name"""
  layout

  """column name"""
  listId

  """column name"""
  sortedBy
}

"""
input type for updating data in table "viewPreferences"
"""
input viewPreferences_set_input {
  isSortingReversed: Boolean
  layout: String
  sortedBy: String
}

"""
Streaming cursor of the table "viewPreferences"
"""
input viewPreferences_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: viewPreferences_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input viewPreferences_stream_cursor_value_input {
  id: uuid
  isSortingReversed: Boolean
  layout: String
  listId: listIdEnum_enum
  sortedBy: String
}

"""
update columns of table "viewPreferences"
"""
enum viewPreferences_update_column {
  """column name"""
  isSortingReversed

  """column name"""
  layout

  """column name"""
  sortedBy
}

input viewPreferences_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: viewPreferences_set_input

  """filter the rows which have to be updated"""
  where: viewPreferences_bool_exp!
}

